import "./chunk-G3PMV62Z.js";

// node_modules/postal-mime/src/decode-strings.js
var textEncoder = new TextEncoder();
var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64Lookup = new Uint8Array(256);
for (i = 0; i < base64Chars.length; i++) {
  base64Lookup[base64Chars.charCodeAt(i)] = i;
}
var i;
function decodeBase64(base64) {
  let bufferLength = Math.ceil(base64.length / 4) * 3;
  const len = base64.length;
  let p = 0;
  if (base64.length % 4 === 3) {
    bufferLength--;
  } else if (base64.length % 4 === 2) {
    bufferLength -= 2;
  } else if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arrayBuffer = new ArrayBuffer(bufferLength);
  const bytes = new Uint8Array(arrayBuffer);
  for (let i = 0; i < len; i += 4) {
    let encoded1 = base64Lookup[base64.charCodeAt(i)];
    let encoded2 = base64Lookup[base64.charCodeAt(i + 1)];
    let encoded3 = base64Lookup[base64.charCodeAt(i + 2)];
    let encoded4 = base64Lookup[base64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arrayBuffer;
}
function getDecoder(charset) {
  charset = charset || "utf8";
  let decoder;
  try {
    decoder = new TextDecoder(charset);
  } catch (err) {
    decoder = new TextDecoder("windows-1252");
  }
  return decoder;
}
async function blobToArrayBuffer(blob) {
  if ("arrayBuffer" in blob) {
    return await blob.arrayBuffer();
  }
  const fr = new FileReader();
  return new Promise((resolve, reject) => {
    fr.onload = function(e) {
      resolve(e.target.result);
    };
    fr.onerror = function(e) {
      reject(fr.error);
    };
    fr.readAsArrayBuffer(blob);
  });
}
function getHex(c) {
  if (c >= 48 && c <= 57 || c >= 97 && c <= 102 || c >= 65 && c <= 70) {
    return String.fromCharCode(c);
  }
  return false;
}
function decodeWord(charset, encoding, str) {
  let splitPos = charset.indexOf("*");
  if (splitPos >= 0) {
    charset = charset.substr(0, splitPos);
  }
  encoding = encoding.toUpperCase();
  let byteStr;
  if (encoding === "Q") {
    str = str.replace(/=\s+([0-9a-fA-F])/g, "=$1").replace(/[_\s]/g, " ");
    let buf = textEncoder.encode(str);
    let encodedBytes = [];
    for (let i = 0, len = buf.length; i < len; i++) {
      let c = buf[i];
      if (i <= len - 2 && c === 61) {
        let c1 = getHex(buf[i + 1]);
        let c2 = getHex(buf[i + 2]);
        if (c1 && c2) {
          let c3 = parseInt(c1 + c2, 16);
          encodedBytes.push(c3);
          i += 2;
          continue;
        }
      }
      encodedBytes.push(c);
    }
    byteStr = new ArrayBuffer(encodedBytes.length);
    let dataView = new DataView(byteStr);
    for (let i = 0, len = encodedBytes.length; i < len; i++) {
      dataView.setUint8(i, encodedBytes[i]);
    }
  } else if (encoding === "B") {
    byteStr = decodeBase64(str.replace(/[^a-zA-Z0-9\+\/=]+/g, ""));
  } else {
    byteStr = textEncoder.encode(str);
  }
  return getDecoder(charset).decode(byteStr);
}
function decodeWords(str) {
  let joinString = true;
  let done = false;
  while (!done) {
    let result = (str || "").toString().replace(/(=\?([^?]+)\?[Bb]\?([^?]*)\?=)\s*(?==\?([^?]+)\?[Bb]\?[^?]*\?=)/g, (match, left, chLeft, encodedLeftStr, chRight) => {
      if (!joinString) {
        return match;
      }
      if (chLeft === chRight && encodedLeftStr.length % 4 === 0 && !/=$/.test(encodedLeftStr)) {
        return left + "__\0JOIN\0__";
      }
      return match;
    }).replace(/(=\?([^?]+)\?[Qq]\?[^?]*\?=)\s*(?==\?([^?]+)\?[Qq]\?[^?]*\?=)/g, (match, left, chLeft, chRight) => {
      if (!joinString) {
        return match;
      }
      if (chLeft === chRight) {
        return left + "__\0JOIN\0__";
      }
      return match;
    }).replace(/(\?=)?__\x00JOIN\x00__(=\?([^?]+)\?[QqBb]\?)?/g, "").replace(/(=\?[^?]+\?[QqBb]\?[^?]*\?=)\s+(?==\?[^?]+\?[QqBb]\?[^?]*\?=)/g, "$1").replace(/=\?([\w_\-*]+)\?([QqBb])\?([^?]*)\?=/g, (m, charset, encoding, text) => decodeWord(charset, encoding, text));
    if (joinString && result.indexOf("ï¿½") >= 0) {
      joinString = false;
    } else {
      return result;
    }
  }
}
function decodeURIComponentWithCharset(encodedStr, charset) {
  charset = charset || "utf-8";
  let encodedBytes = [];
  for (let i = 0; i < encodedStr.length; i++) {
    let c = encodedStr.charAt(i);
    if (c === "%" && /^[a-f0-9]{2}/i.test(encodedStr.substr(i + 1, 2))) {
      let byte = encodedStr.substr(i + 1, 2);
      i += 2;
      encodedBytes.push(parseInt(byte, 16));
    } else if (c.charCodeAt(0) > 126) {
      c = textEncoder.encode(c);
      for (let j = 0; j < c.length; j++) {
        encodedBytes.push(c[j]);
      }
    } else {
      encodedBytes.push(c.charCodeAt(0));
    }
  }
  const byteStr = new ArrayBuffer(encodedBytes.length);
  const dataView = new DataView(byteStr);
  for (let i = 0, len = encodedBytes.length; i < len; i++) {
    dataView.setUint8(i, encodedBytes[i]);
  }
  return getDecoder(charset).decode(byteStr);
}
function decodeParameterValueContinuations(header) {
  let paramKeys = /* @__PURE__ */ new Map();
  Object.keys(header.params).forEach((key) => {
    let match = key.match(/\*((\d+)\*?)?$/);
    if (!match) {
      return;
    }
    let actualKey = key.substr(0, match.index).toLowerCase();
    let nr = Number(match[2]) || 0;
    let paramVal;
    if (!paramKeys.has(actualKey)) {
      paramVal = {
        charset: false,
        values: []
      };
      paramKeys.set(actualKey, paramVal);
    } else {
      paramVal = paramKeys.get(actualKey);
    }
    let value = header.params[key];
    if (nr === 0 && match[0].charAt(match[0].length - 1) === "*" && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {
      paramVal.charset = match[1] || "utf-8";
      value = match[2];
    }
    paramVal.values.push({ nr, value });
    delete header.params[key];
  });
  paramKeys.forEach((paramVal, key) => {
    header.params[key] = decodeURIComponentWithCharset(
      paramVal.values.sort((a, b) => a.nr - b.nr).map((a) => a.value).join(""),
      paramVal.charset
    );
  });
}

// node_modules/postal-mime/src/pass-through-decoder.js
var PassThroughDecoder = class {
  constructor() {
    this.chunks = [];
  }
  update(line) {
    this.chunks.push(line);
    this.chunks.push("\n");
  }
  finalize() {
    return blobToArrayBuffer(new Blob(this.chunks, { type: "application/octet-stream" }));
  }
};

// node_modules/postal-mime/src/base64-decoder.js
var Base64Decoder = class {
  constructor(opts) {
    opts = opts || {};
    this.decoder = opts.decoder || new TextDecoder();
    this.maxChunkSize = 100 * 1024;
    this.chunks = [];
    this.remainder = "";
  }
  update(buffer) {
    let str = this.decoder.decode(buffer);
    if (/[^a-zA-Z0-9+\/]/.test(str)) {
      str = str.replace(/[^a-zA-Z0-9+\/]+/g, "");
    }
    this.remainder += str;
    if (this.remainder.length >= this.maxChunkSize) {
      let allowedBytes = Math.floor(this.remainder.length / 4) * 4;
      let base64Str;
      if (allowedBytes === this.remainder.length) {
        base64Str = this.remainder;
        this.remainder = "";
      } else {
        base64Str = this.remainder.substr(0, allowedBytes);
        this.remainder = this.remainder.substr(allowedBytes);
      }
      if (base64Str.length) {
        this.chunks.push(decodeBase64(base64Str));
      }
    }
  }
  finalize() {
    if (this.remainder && !/^=+$/.test(this.remainder)) {
      this.chunks.push(decodeBase64(this.remainder));
    }
    return blobToArrayBuffer(new Blob(this.chunks, { type: "application/octet-stream" }));
  }
};

// node_modules/postal-mime/src/qp-decoder.js
var QPDecoder = class {
  constructor(opts) {
    opts = opts || {};
    this.decoder = opts.decoder || new TextDecoder();
    this.maxChunkSize = 100 * 1024;
    this.remainder = "";
    this.chunks = [];
  }
  decodeQPBytes(encodedBytes) {
    let buf = new ArrayBuffer(encodedBytes.length);
    let dataView = new DataView(buf);
    for (let i = 0, len = encodedBytes.length; i < len; i++) {
      dataView.setUint8(i, parseInt(encodedBytes[i], 16));
    }
    return buf;
  }
  decodeChunks(str) {
    str = str.replace(/=\r?\n/g, "");
    let list = str.split(/(?==)/);
    let encodedBytes = [];
    for (let part of list) {
      if (part.charAt(0) !== "=") {
        if (encodedBytes.length) {
          this.chunks.push(this.decodeQPBytes(encodedBytes));
          encodedBytes = [];
        }
        this.chunks.push(part);
        continue;
      }
      if (part.length === 3) {
        encodedBytes.push(part.substr(1));
        continue;
      }
      if (part.length > 3) {
        encodedBytes.push(part.substr(1, 2));
        this.chunks.push(this.decodeQPBytes(encodedBytes));
        encodedBytes = [];
        part = part.substr(3);
        this.chunks.push(part);
      }
    }
    if (encodedBytes.length) {
      this.chunks.push(this.decodeQPBytes(encodedBytes));
      encodedBytes = [];
    }
  }
  update(buffer) {
    let str = this.decoder.decode(buffer) + "\n";
    str = this.remainder + str;
    if (str.length < this.maxChunkSize) {
      this.remainder = str;
      return;
    }
    this.remainder = "";
    let partialEnding = str.match(/=[a-fA-F0-9]?$/);
    if (partialEnding) {
      if (partialEnding.index === 0) {
        this.remainder = str;
        return;
      }
      this.remainder = str.substr(partialEnding.index);
      str = str.substr(0, partialEnding.index);
    }
    this.decodeChunks(str);
  }
  finalize() {
    if (this.remainder.length) {
      this.decodeChunks(this.remainder);
      this.remainder = "";
    }
    return blobToArrayBuffer(new Blob(this.chunks, { type: "application/octet-stream" }));
  }
};

// node_modules/postal-mime/src/mime-node.js
var MimeNode = class {
  constructor(opts) {
    opts = opts || {};
    this.postalMime = opts.postalMime;
    this.root = !!opts.parentNode;
    this.childNodes = [];
    if (opts.parentNode) {
      opts.parentNode.childNodes.push(this);
    }
    this.state = "header";
    this.headerLines = [];
    this.contentType = {
      value: "text/plain",
      default: true
    };
    this.contentTransferEncoding = {
      value: "8bit"
    };
    this.contentDisposition = {
      value: ""
    };
    this.headers = [];
    this.contentDecoder = false;
  }
  setupContentDecoder(transferEncoding) {
    if (/base64/i.test(transferEncoding)) {
      this.contentDecoder = new Base64Decoder();
    } else if (/quoted-printable/i.test(transferEncoding)) {
      this.contentDecoder = new QPDecoder({ decoder: getDecoder(this.contentType.parsed.params.charset) });
    } else {
      this.contentDecoder = new PassThroughDecoder();
    }
  }
  async finalize() {
    if (this.state === "finished") {
      return;
    }
    if (this.state === "header") {
      this.processHeaders();
    }
    let boundaries = this.postalMime.boundaries;
    for (let i = boundaries.length - 1; i >= 0; i--) {
      let boundary = boundaries[i];
      if (boundary.node === this) {
        boundaries.splice(i, 1);
        break;
      }
    }
    await this.finalizeChildNodes();
    this.content = this.contentDecoder ? await this.contentDecoder.finalize() : null;
    this.state = "finished";
  }
  async finalizeChildNodes() {
    for (let childNode of this.childNodes) {
      await childNode.finalize();
    }
  }
  parseStructuredHeader(str) {
    let response = {
      value: false,
      params: {}
    };
    let key = false;
    let value = "";
    let stage = "value";
    let quote = false;
    let escaped = false;
    let chr;
    for (let i = 0, len = str.length; i < len; i++) {
      chr = str.charAt(i);
      switch (stage) {
        case "key":
          if (chr === "=") {
            key = value.trim().toLowerCase();
            stage = "value";
            value = "";
            break;
          }
          value += chr;
          break;
        case "value":
          if (escaped) {
            value += chr;
          } else if (chr === "\\") {
            escaped = true;
            continue;
          } else if (quote && chr === quote) {
            quote = false;
          } else if (!quote && chr === '"') {
            quote = chr;
          } else if (!quote && chr === ";") {
            if (key === false) {
              response.value = value.trim();
            } else {
              response.params[key] = value.trim();
            }
            stage = "key";
            value = "";
          } else {
            value += chr;
          }
          escaped = false;
          break;
      }
    }
    value = value.trim();
    if (stage === "value") {
      if (key === false) {
        response.value = value;
      } else {
        response.params[key] = value;
      }
    } else if (value) {
      response.params[value.toLowerCase()] = "";
    }
    if (response.value) {
      response.value = response.value.toLowerCase();
    }
    decodeParameterValueContinuations(response);
    return response;
  }
  decodeFlowedText(str, delSp) {
    return str.split(/\r?\n/).reduce((previousValue, currentValue) => {
      if (/ $/.test(previousValue) && !/(^|\n)-- $/.test(previousValue)) {
        if (delSp) {
          return previousValue.slice(0, -1) + currentValue;
        } else {
          return previousValue + currentValue;
        }
      } else {
        return previousValue + "\n" + currentValue;
      }
    }).replace(/^ /gm, "");
  }
  getTextContent() {
    if (!this.content) {
      return "";
    }
    let str = getDecoder(this.contentType.parsed.params.charset).decode(this.content);
    if (/^flowed$/i.test(this.contentType.parsed.params.format)) {
      str = this.decodeFlowedText(str, /^yes$/i.test(this.contentType.parsed.params.delsp));
    }
    return str;
  }
  processHeaders() {
    for (let i = this.headerLines.length - 1; i >= 0; i--) {
      let line = this.headerLines[i];
      if (i && /^\s/.test(line)) {
        this.headerLines[i - 1] += "\n" + line;
        this.headerLines.splice(i, 1);
      } else {
        line = line.replace(/\s+/g, " ");
        let sep = line.indexOf(":");
        let key = sep < 0 ? line.trim() : line.substr(0, sep).trim();
        let value = sep < 0 ? "" : line.substr(sep + 1).trim();
        this.headers.push({ key: key.toLowerCase(), originalKey: key, value });
        switch (key.toLowerCase()) {
          case "content-type":
            if (this.contentType.default) {
              this.contentType = { value, parsed: {} };
            }
            break;
          case "content-transfer-encoding":
            this.contentTransferEncoding = { value, parsed: {} };
            break;
          case "content-disposition":
            this.contentDisposition = { value, parsed: {} };
            break;
          case "content-id":
            this.contentId = value;
            break;
          case "content-description":
            this.contentDescription = value;
            break;
        }
      }
    }
    this.contentType.parsed = this.parseStructuredHeader(this.contentType.value);
    this.contentType.multipart = /^multipart\//i.test(this.contentType.parsed.value) ? this.contentType.parsed.value.substr(this.contentType.parsed.value.indexOf("/") + 1) : false;
    if (this.contentType.multipart && this.contentType.parsed.params.boundary) {
      this.postalMime.boundaries.push({
        value: textEncoder.encode(this.contentType.parsed.params.boundary),
        node: this
      });
    }
    this.contentDisposition.parsed = this.parseStructuredHeader(this.contentDisposition.value);
    this.contentTransferEncoding.encoding = this.contentTransferEncoding.value.toLowerCase().split(/[^\w-]/).shift();
    this.setupContentDecoder(this.contentTransferEncoding.encoding);
  }
  feed(line) {
    switch (this.state) {
      case "header":
        if (!line.length) {
          this.state = "body";
          return this.processHeaders();
        }
        this.headerLines.push(getDecoder().decode(line));
        break;
      case "body": {
        this.contentDecoder.update(line);
      }
    }
  }
};

// node_modules/postal-mime/src/html-entities.js
var htmlEntities = {
  "&AElig": "Ã",
  "&AElig;": "Ã",
  "&AMP": "&",
  "&AMP;": "&",
  "&Aacute": "Ã",
  "&Aacute;": "Ã",
  "&Abreve;": "Ä",
  "&Acirc": "Ã",
  "&Acirc;": "Ã",
  "&Acy;": "Ð",
  "&Afr;": "ð",
  "&Agrave": "Ã",
  "&Agrave;": "Ã",
  "&Alpha;": "Î",
  "&Amacr;": "Ä",
  "&And;": "â©",
  "&Aogon;": "Ä",
  "&Aopf;": "ð¸",
  "&ApplyFunction;": "â¡",
  "&Aring": "Ã",
  "&Aring;": "Ã",
  "&Ascr;": "ð",
  "&Assign;": "â",
  "&Atilde": "Ã",
  "&Atilde;": "Ã",
  "&Auml": "Ã",
  "&Auml;": "Ã",
  "&Backslash;": "â",
  "&Barv;": "â«§",
  "&Barwed;": "â",
  "&Bcy;": "Ð",
  "&Because;": "âµ",
  "&Bernoullis;": "â¬",
  "&Beta;": "Î",
  "&Bfr;": "ð",
  "&Bopf;": "ð¹",
  "&Breve;": "Ë",
  "&Bscr;": "â¬",
  "&Bumpeq;": "â",
  "&CHcy;": "Ð§",
  "&COPY": "Â©",
  "&COPY;": "Â©",
  "&Cacute;": "Ä",
  "&Cap;": "â",
  "&CapitalDifferentialD;": "â",
  "&Cayleys;": "â­",
  "&Ccaron;": "Ä",
  "&Ccedil": "Ã",
  "&Ccedil;": "Ã",
  "&Ccirc;": "Ä",
  "&Cconint;": "â°",
  "&Cdot;": "Ä",
  "&Cedilla;": "Â¸",
  "&CenterDot;": "Â·",
  "&Cfr;": "â­",
  "&Chi;": "Î§",
  "&CircleDot;": "â",
  "&CircleMinus;": "â",
  "&CirclePlus;": "â",
  "&CircleTimes;": "â",
  "&ClockwiseContourIntegral;": "â²",
  "&CloseCurlyDoubleQuote;": "â",
  "&CloseCurlyQuote;": "â",
  "&Colon;": "â·",
  "&Colone;": "â©´",
  "&Congruent;": "â¡",
  "&Conint;": "â¯",
  "&ContourIntegral;": "â®",
  "&Copf;": "â",
  "&Coproduct;": "â",
  "&CounterClockwiseContourIntegral;": "â³",
  "&Cross;": "â¨¯",
  "&Cscr;": "ð",
  "&Cup;": "â",
  "&CupCap;": "â",
  "&DD;": "â",
  "&DDotrahd;": "â¤",
  "&DJcy;": "Ð",
  "&DScy;": "Ð",
  "&DZcy;": "Ð",
  "&Dagger;": "â¡",
  "&Darr;": "â¡",
  "&Dashv;": "â«¤",
  "&Dcaron;": "Ä",
  "&Dcy;": "Ð",
  "&Del;": "â",
  "&Delta;": "Î",
  "&Dfr;": "ð",
  "&DiacriticalAcute;": "Â´",
  "&DiacriticalDot;": "Ë",
  "&DiacriticalDoubleAcute;": "Ë",
  "&DiacriticalGrave;": "`",
  "&DiacriticalTilde;": "Ë",
  "&Diamond;": "â",
  "&DifferentialD;": "â",
  "&Dopf;": "ð»",
  "&Dot;": "Â¨",
  "&DotDot;": "â",
  "&DotEqual;": "â",
  "&DoubleContourIntegral;": "â¯",
  "&DoubleDot;": "Â¨",
  "&DoubleDownArrow;": "â",
  "&DoubleLeftArrow;": "â",
  "&DoubleLeftRightArrow;": "â",
  "&DoubleLeftTee;": "â«¤",
  "&DoubleLongLeftArrow;": "â¸",
  "&DoubleLongLeftRightArrow;": "âº",
  "&DoubleLongRightArrow;": "â¹",
  "&DoubleRightArrow;": "â",
  "&DoubleRightTee;": "â¨",
  "&DoubleUpArrow;": "â",
  "&DoubleUpDownArrow;": "â",
  "&DoubleVerticalBar;": "â¥",
  "&DownArrow;": "â",
  "&DownArrowBar;": "â¤",
  "&DownArrowUpArrow;": "âµ",
  "&DownBreve;": "Ì",
  "&DownLeftRightVector;": "â¥",
  "&DownLeftTeeVector;": "â¥",
  "&DownLeftVector;": "â½",
  "&DownLeftVectorBar;": "â¥",
  "&DownRightTeeVector;": "â¥",
  "&DownRightVector;": "â",
  "&DownRightVectorBar;": "â¥",
  "&DownTee;": "â¤",
  "&DownTeeArrow;": "â§",
  "&Downarrow;": "â",
  "&Dscr;": "ð",
  "&Dstrok;": "Ä",
  "&ENG;": "Å",
  "&ETH": "Ã",
  "&ETH;": "Ã",
  "&Eacute": "Ã",
  "&Eacute;": "Ã",
  "&Ecaron;": "Ä",
  "&Ecirc": "Ã",
  "&Ecirc;": "Ã",
  "&Ecy;": "Ð­",
  "&Edot;": "Ä",
  "&Efr;": "ð",
  "&Egrave": "Ã",
  "&Egrave;": "Ã",
  "&Element;": "â",
  "&Emacr;": "Ä",
  "&EmptySmallSquare;": "â»",
  "&EmptyVerySmallSquare;": "â«",
  "&Eogon;": "Ä",
  "&Eopf;": "ð¼",
  "&Epsilon;": "Î",
  "&Equal;": "â©µ",
  "&EqualTilde;": "â",
  "&Equilibrium;": "â",
  "&Escr;": "â°",
  "&Esim;": "â©³",
  "&Eta;": "Î",
  "&Euml": "Ã",
  "&Euml;": "Ã",
  "&Exists;": "â",
  "&ExponentialE;": "â",
  "&Fcy;": "Ð¤",
  "&Ffr;": "ð",
  "&FilledSmallSquare;": "â¼",
  "&FilledVerySmallSquare;": "âª",
  "&Fopf;": "ð½",
  "&ForAll;": "â",
  "&Fouriertrf;": "â±",
  "&Fscr;": "â±",
  "&GJcy;": "Ð",
  "&GT": ">",
  "&GT;": ">",
  "&Gamma;": "Î",
  "&Gammad;": "Ï",
  "&Gbreve;": "Ä",
  "&Gcedil;": "Ä¢",
  "&Gcirc;": "Ä",
  "&Gcy;": "Ð",
  "&Gdot;": "Ä ",
  "&Gfr;": "ð",
  "&Gg;": "â",
  "&Gopf;": "ð¾",
  "&GreaterEqual;": "â¥",
  "&GreaterEqualLess;": "â",
  "&GreaterFullEqual;": "â§",
  "&GreaterGreater;": "âª¢",
  "&GreaterLess;": "â·",
  "&GreaterSlantEqual;": "â©¾",
  "&GreaterTilde;": "â³",
  "&Gscr;": "ð¢",
  "&Gt;": "â«",
  "&HARDcy;": "Ðª",
  "&Hacek;": "Ë",
  "&Hat;": "^",
  "&Hcirc;": "Ä¤",
  "&Hfr;": "â",
  "&HilbertSpace;": "â",
  "&Hopf;": "â",
  "&HorizontalLine;": "â",
  "&Hscr;": "â",
  "&Hstrok;": "Ä¦",
  "&HumpDownHump;": "â",
  "&HumpEqual;": "â",
  "&IEcy;": "Ð",
  "&IJlig;": "Ä²",
  "&IOcy;": "Ð",
  "&Iacute": "Ã",
  "&Iacute;": "Ã",
  "&Icirc": "Ã",
  "&Icirc;": "Ã",
  "&Icy;": "Ð",
  "&Idot;": "Ä°",
  "&Ifr;": "â",
  "&Igrave": "Ã",
  "&Igrave;": "Ã",
  "&Im;": "â",
  "&Imacr;": "Äª",
  "&ImaginaryI;": "â",
  "&Implies;": "â",
  "&Int;": "â¬",
  "&Integral;": "â«",
  "&Intersection;": "â",
  "&InvisibleComma;": "â£",
  "&InvisibleTimes;": "â¢",
  "&Iogon;": "Ä®",
  "&Iopf;": "ð",
  "&Iota;": "Î",
  "&Iscr;": "â",
  "&Itilde;": "Ä¨",
  "&Iukcy;": "Ð",
  "&Iuml": "Ã",
  "&Iuml;": "Ã",
  "&Jcirc;": "Ä´",
  "&Jcy;": "Ð",
  "&Jfr;": "ð",
  "&Jopf;": "ð",
  "&Jscr;": "ð¥",
  "&Jsercy;": "Ð",
  "&Jukcy;": "Ð",
  "&KHcy;": "Ð¥",
  "&KJcy;": "Ð",
  "&Kappa;": "Î",
  "&Kcedil;": "Ä¶",
  "&Kcy;": "Ð",
  "&Kfr;": "ð",
  "&Kopf;": "ð",
  "&Kscr;": "ð¦",
  "&LJcy;": "Ð",
  "&LT": "<",
  "&LT;": "<",
  "&Lacute;": "Ä¹",
  "&Lambda;": "Î",
  "&Lang;": "âª",
  "&Laplacetrf;": "â",
  "&Larr;": "â",
  "&Lcaron;": "Ä½",
  "&Lcedil;": "Ä»",
  "&Lcy;": "Ð",
  "&LeftAngleBracket;": "â¨",
  "&LeftArrow;": "â",
  "&LeftArrowBar;": "â¤",
  "&LeftArrowRightArrow;": "â",
  "&LeftCeiling;": "â",
  "&LeftDoubleBracket;": "â¦",
  "&LeftDownTeeVector;": "â¥¡",
  "&LeftDownVector;": "â",
  "&LeftDownVectorBar;": "â¥",
  "&LeftFloor;": "â",
  "&LeftRightArrow;": "â",
  "&LeftRightVector;": "â¥",
  "&LeftTee;": "â£",
  "&LeftTeeArrow;": "â¤",
  "&LeftTeeVector;": "â¥",
  "&LeftTriangle;": "â²",
  "&LeftTriangleBar;": "â§",
  "&LeftTriangleEqual;": "â´",
  "&LeftUpDownVector;": "â¥",
  "&LeftUpTeeVector;": "â¥ ",
  "&LeftUpVector;": "â¿",
  "&LeftUpVectorBar;": "â¥",
  "&LeftVector;": "â¼",
  "&LeftVectorBar;": "â¥",
  "&Leftarrow;": "â",
  "&Leftrightarrow;": "â",
  "&LessEqualGreater;": "â",
  "&LessFullEqual;": "â¦",
  "&LessGreater;": "â¶",
  "&LessLess;": "âª¡",
  "&LessSlantEqual;": "â©½",
  "&LessTilde;": "â²",
  "&Lfr;": "ð",
  "&Ll;": "â",
  "&Lleftarrow;": "â",
  "&Lmidot;": "Ä¿",
  "&LongLeftArrow;": "âµ",
  "&LongLeftRightArrow;": "â·",
  "&LongRightArrow;": "â¶",
  "&Longleftarrow;": "â¸",
  "&Longleftrightarrow;": "âº",
  "&Longrightarrow;": "â¹",
  "&Lopf;": "ð",
  "&LowerLeftArrow;": "â",
  "&LowerRightArrow;": "â",
  "&Lscr;": "â",
  "&Lsh;": "â°",
  "&Lstrok;": "Å",
  "&Lt;": "âª",
  "&Map;": "â¤",
  "&Mcy;": "Ð",
  "&MediumSpace;": "â",
  "&Mellintrf;": "â³",
  "&Mfr;": "ð",
  "&MinusPlus;": "â",
  "&Mopf;": "ð",
  "&Mscr;": "â³",
  "&Mu;": "Î",
  "&NJcy;": "Ð",
  "&Nacute;": "Å",
  "&Ncaron;": "Å",
  "&Ncedil;": "Å",
  "&Ncy;": "Ð",
  "&NegativeMediumSpace;": "â",
  "&NegativeThickSpace;": "â",
  "&NegativeThinSpace;": "â",
  "&NegativeVeryThinSpace;": "â",
  "&NestedGreaterGreater;": "â«",
  "&NestedLessLess;": "âª",
  "&NewLine;": "\n",
  "&Nfr;": "ð",
  "&NoBreak;": "â ",
  "&NonBreakingSpace;": "Â ",
  "&Nopf;": "â",
  "&Not;": "â«¬",
  "&NotCongruent;": "â¢",
  "&NotCupCap;": "â­",
  "&NotDoubleVerticalBar;": "â¦",
  "&NotElement;": "â",
  "&NotEqual;": "â ",
  "&NotEqualTilde;": "âÌ¸",
  "&NotExists;": "â",
  "&NotGreater;": "â¯",
  "&NotGreaterEqual;": "â±",
  "&NotGreaterFullEqual;": "â§Ì¸",
  "&NotGreaterGreater;": "â«Ì¸",
  "&NotGreaterLess;": "â¹",
  "&NotGreaterSlantEqual;": "â©¾Ì¸",
  "&NotGreaterTilde;": "âµ",
  "&NotHumpDownHump;": "âÌ¸",
  "&NotHumpEqual;": "âÌ¸",
  "&NotLeftTriangle;": "âª",
  "&NotLeftTriangleBar;": "â§Ì¸",
  "&NotLeftTriangleEqual;": "â¬",
  "&NotLess;": "â®",
  "&NotLessEqual;": "â°",
  "&NotLessGreater;": "â¸",
  "&NotLessLess;": "âªÌ¸",
  "&NotLessSlantEqual;": "â©½Ì¸",
  "&NotLessTilde;": "â´",
  "&NotNestedGreaterGreater;": "âª¢Ì¸",
  "&NotNestedLessLess;": "âª¡Ì¸",
  "&NotPrecedes;": "â",
  "&NotPrecedesEqual;": "âª¯Ì¸",
  "&NotPrecedesSlantEqual;": "â ",
  "&NotReverseElement;": "â",
  "&NotRightTriangle;": "â«",
  "&NotRightTriangleBar;": "â§Ì¸",
  "&NotRightTriangleEqual;": "â­",
  "&NotSquareSubset;": "âÌ¸",
  "&NotSquareSubsetEqual;": "â¢",
  "&NotSquareSuperset;": "âÌ¸",
  "&NotSquareSupersetEqual;": "â£",
  "&NotSubset;": "ââ",
  "&NotSubsetEqual;": "â",
  "&NotSucceeds;": "â",
  "&NotSucceedsEqual;": "âª°Ì¸",
  "&NotSucceedsSlantEqual;": "â¡",
  "&NotSucceedsTilde;": "â¿Ì¸",
  "&NotSuperset;": "ââ",
  "&NotSupersetEqual;": "â",
  "&NotTilde;": "â",
  "&NotTildeEqual;": "â",
  "&NotTildeFullEqual;": "â",
  "&NotTildeTilde;": "â",
  "&NotVerticalBar;": "â¤",
  "&Nscr;": "ð©",
  "&Ntilde": "Ã",
  "&Ntilde;": "Ã",
  "&Nu;": "Î",
  "&OElig;": "Å",
  "&Oacute": "Ã",
  "&Oacute;": "Ã",
  "&Ocirc": "Ã",
  "&Ocirc;": "Ã",
  "&Ocy;": "Ð",
  "&Odblac;": "Å",
  "&Ofr;": "ð",
  "&Ograve": "Ã",
  "&Ograve;": "Ã",
  "&Omacr;": "Å",
  "&Omega;": "Î©",
  "&Omicron;": "Î",
  "&Oopf;": "ð",
  "&OpenCurlyDoubleQuote;": "â",
  "&OpenCurlyQuote;": "â",
  "&Or;": "â©",
  "&Oscr;": "ðª",
  "&Oslash": "Ã",
  "&Oslash;": "Ã",
  "&Otilde": "Ã",
  "&Otilde;": "Ã",
  "&Otimes;": "â¨·",
  "&Ouml": "Ã",
  "&Ouml;": "Ã",
  "&OverBar;": "â¾",
  "&OverBrace;": "â",
  "&OverBracket;": "â´",
  "&OverParenthesis;": "â",
  "&PartialD;": "â",
  "&Pcy;": "Ð",
  "&Pfr;": "ð",
  "&Phi;": "Î¦",
  "&Pi;": "Î ",
  "&PlusMinus;": "Â±",
  "&Poincareplane;": "â",
  "&Popf;": "â",
  "&Pr;": "âª»",
  "&Precedes;": "âº",
  "&PrecedesEqual;": "âª¯",
  "&PrecedesSlantEqual;": "â¼",
  "&PrecedesTilde;": "â¾",
  "&Prime;": "â³",
  "&Product;": "â",
  "&Proportion;": "â·",
  "&Proportional;": "â",
  "&Pscr;": "ð«",
  "&Psi;": "Î¨",
  "&QUOT": '"',
  "&QUOT;": '"',
  "&Qfr;": "ð",
  "&Qopf;": "â",
  "&Qscr;": "ð¬",
  "&RBarr;": "â¤",
  "&REG": "Â®",
  "&REG;": "Â®",
  "&Racute;": "Å",
  "&Rang;": "â«",
  "&Rarr;": "â ",
  "&Rarrtl;": "â¤",
  "&Rcaron;": "Å",
  "&Rcedil;": "Å",
  "&Rcy;": "Ð ",
  "&Re;": "â",
  "&ReverseElement;": "â",
  "&ReverseEquilibrium;": "â",
  "&ReverseUpEquilibrium;": "â¥¯",
  "&Rfr;": "â",
  "&Rho;": "Î¡",
  "&RightAngleBracket;": "â©",
  "&RightArrow;": "â",
  "&RightArrowBar;": "â¥",
  "&RightArrowLeftArrow;": "â",
  "&RightCeiling;": "â",
  "&RightDoubleBracket;": "â§",
  "&RightDownTeeVector;": "â¥",
  "&RightDownVector;": "â",
  "&RightDownVectorBar;": "â¥",
  "&RightFloor;": "â",
  "&RightTee;": "â¢",
  "&RightTeeArrow;": "â¦",
  "&RightTeeVector;": "â¥",
  "&RightTriangle;": "â³",
  "&RightTriangleBar;": "â§",
  "&RightTriangleEqual;": "âµ",
  "&RightUpDownVector;": "â¥",
  "&RightUpTeeVector;": "â¥",
  "&RightUpVector;": "â¾",
  "&RightUpVectorBar;": "â¥",
  "&RightVector;": "â",
  "&RightVectorBar;": "â¥",
  "&Rightarrow;": "â",
  "&Ropf;": "â",
  "&RoundImplies;": "â¥°",
  "&Rrightarrow;": "â",
  "&Rscr;": "â",
  "&Rsh;": "â±",
  "&RuleDelayed;": "â§´",
  "&SHCHcy;": "Ð©",
  "&SHcy;": "Ð¨",
  "&SOFTcy;": "Ð¬",
  "&Sacute;": "Å",
  "&Sc;": "âª¼",
  "&Scaron;": "Å ",
  "&Scedil;": "Å",
  "&Scirc;": "Å",
  "&Scy;": "Ð¡",
  "&Sfr;": "ð",
  "&ShortDownArrow;": "â",
  "&ShortLeftArrow;": "â",
  "&ShortRightArrow;": "â",
  "&ShortUpArrow;": "â",
  "&Sigma;": "Î£",
  "&SmallCircle;": "â",
  "&Sopf;": "ð",
  "&Sqrt;": "â",
  "&Square;": "â¡",
  "&SquareIntersection;": "â",
  "&SquareSubset;": "â",
  "&SquareSubsetEqual;": "â",
  "&SquareSuperset;": "â",
  "&SquareSupersetEqual;": "â",
  "&SquareUnion;": "â",
  "&Sscr;": "ð®",
  "&Star;": "â",
  "&Sub;": "â",
  "&Subset;": "â",
  "&SubsetEqual;": "â",
  "&Succeeds;": "â»",
  "&SucceedsEqual;": "âª°",
  "&SucceedsSlantEqual;": "â½",
  "&SucceedsTilde;": "â¿",
  "&SuchThat;": "â",
  "&Sum;": "â",
  "&Sup;": "â",
  "&Superset;": "â",
  "&SupersetEqual;": "â",
  "&Supset;": "â",
  "&THORN": "Ã",
  "&THORN;": "Ã",
  "&TRADE;": "â¢",
  "&TSHcy;": "Ð",
  "&TScy;": "Ð¦",
  "&Tab;": "	",
  "&Tau;": "Î¤",
  "&Tcaron;": "Å¤",
  "&Tcedil;": "Å¢",
  "&Tcy;": "Ð¢",
  "&Tfr;": "ð",
  "&Therefore;": "â´",
  "&Theta;": "Î",
  "&ThickSpace;": "ââ",
  "&ThinSpace;": "â",
  "&Tilde;": "â¼",
  "&TildeEqual;": "â",
  "&TildeFullEqual;": "â",
  "&TildeTilde;": "â",
  "&Topf;": "ð",
  "&TripleDot;": "â",
  "&Tscr;": "ð¯",
  "&Tstrok;": "Å¦",
  "&Uacute": "Ã",
  "&Uacute;": "Ã",
  "&Uarr;": "â",
  "&Uarrocir;": "â¥",
  "&Ubrcy;": "Ð",
  "&Ubreve;": "Å¬",
  "&Ucirc": "Ã",
  "&Ucirc;": "Ã",
  "&Ucy;": "Ð£",
  "&Udblac;": "Å°",
  "&Ufr;": "ð",
  "&Ugrave": "Ã",
  "&Ugrave;": "Ã",
  "&Umacr;": "Åª",
  "&UnderBar;": "_",
  "&UnderBrace;": "â",
  "&UnderBracket;": "âµ",
  "&UnderParenthesis;": "â",
  "&Union;": "â",
  "&UnionPlus;": "â",
  "&Uogon;": "Å²",
  "&Uopf;": "ð",
  "&UpArrow;": "â",
  "&UpArrowBar;": "â¤",
  "&UpArrowDownArrow;": "â",
  "&UpDownArrow;": "â",
  "&UpEquilibrium;": "â¥®",
  "&UpTee;": "â¥",
  "&UpTeeArrow;": "â¥",
  "&Uparrow;": "â",
  "&Updownarrow;": "â",
  "&UpperLeftArrow;": "â",
  "&UpperRightArrow;": "â",
  "&Upsi;": "Ï",
  "&Upsilon;": "Î¥",
  "&Uring;": "Å®",
  "&Uscr;": "ð°",
  "&Utilde;": "Å¨",
  "&Uuml": "Ã",
  "&Uuml;": "Ã",
  "&VDash;": "â«",
  "&Vbar;": "â««",
  "&Vcy;": "Ð",
  "&Vdash;": "â©",
  "&Vdashl;": "â«¦",
  "&Vee;": "â",
  "&Verbar;": "â",
  "&Vert;": "â",
  "&VerticalBar;": "â£",
  "&VerticalLine;": "|",
  "&VerticalSeparator;": "â",
  "&VerticalTilde;": "â",
  "&VeryThinSpace;": "â",
  "&Vfr;": "ð",
  "&Vopf;": "ð",
  "&Vscr;": "ð±",
  "&Vvdash;": "âª",
  "&Wcirc;": "Å´",
  "&Wedge;": "â",
  "&Wfr;": "ð",
  "&Wopf;": "ð",
  "&Wscr;": "ð²",
  "&Xfr;": "ð",
  "&Xi;": "Î",
  "&Xopf;": "ð",
  "&Xscr;": "ð³",
  "&YAcy;": "Ð¯",
  "&YIcy;": "Ð",
  "&YUcy;": "Ð®",
  "&Yacute": "Ã",
  "&Yacute;": "Ã",
  "&Ycirc;": "Å¶",
  "&Ycy;": "Ð«",
  "&Yfr;": "ð",
  "&Yopf;": "ð",
  "&Yscr;": "ð´",
  "&Yuml;": "Å¸",
  "&ZHcy;": "Ð",
  "&Zacute;": "Å¹",
  "&Zcaron;": "Å½",
  "&Zcy;": "Ð",
  "&Zdot;": "Å»",
  "&ZeroWidthSpace;": "â",
  "&Zeta;": "Î",
  "&Zfr;": "â¨",
  "&Zopf;": "â¤",
  "&Zscr;": "ðµ",
  "&aacute": "Ã¡",
  "&aacute;": "Ã¡",
  "&abreve;": "Ä",
  "&ac;": "â¾",
  "&acE;": "â¾Ì³",
  "&acd;": "â¿",
  "&acirc": "Ã¢",
  "&acirc;": "Ã¢",
  "&acute": "Â´",
  "&acute;": "Â´",
  "&acy;": "Ð°",
  "&aelig": "Ã¦",
  "&aelig;": "Ã¦",
  "&af;": "â¡",
  "&afr;": "ð",
  "&agrave": "Ã ",
  "&agrave;": "Ã ",
  "&alefsym;": "âµ",
  "&aleph;": "âµ",
  "&alpha;": "Î±",
  "&amacr;": "Ä",
  "&amalg;": "â¨¿",
  "&amp": "&",
  "&amp;": "&",
  "&and;": "â§",
  "&andand;": "â©",
  "&andd;": "â©",
  "&andslope;": "â©",
  "&andv;": "â©",
  "&ang;": "â ",
  "&ange;": "â¦¤",
  "&angle;": "â ",
  "&angmsd;": "â¡",
  "&angmsdaa;": "â¦¨",
  "&angmsdab;": "â¦©",
  "&angmsdac;": "â¦ª",
  "&angmsdad;": "â¦«",
  "&angmsdae;": "â¦¬",
  "&angmsdaf;": "â¦­",
  "&angmsdag;": "â¦®",
  "&angmsdah;": "â¦¯",
  "&angrt;": "â",
  "&angrtvb;": "â¾",
  "&angrtvbd;": "â¦",
  "&angsph;": "â¢",
  "&angst;": "Ã",
  "&angzarr;": "â¼",
  "&aogon;": "Ä",
  "&aopf;": "ð",
  "&ap;": "â",
  "&apE;": "â©°",
  "&apacir;": "â©¯",
  "&ape;": "â",
  "&apid;": "â",
  "&apos;": "'",
  "&approx;": "â",
  "&approxeq;": "â",
  "&aring": "Ã¥",
  "&aring;": "Ã¥",
  "&ascr;": "ð¶",
  "&ast;": "*",
  "&asymp;": "â",
  "&asympeq;": "â",
  "&atilde": "Ã£",
  "&atilde;": "Ã£",
  "&auml": "Ã¤",
  "&auml;": "Ã¤",
  "&awconint;": "â³",
  "&awint;": "â¨",
  "&bNot;": "â«­",
  "&backcong;": "â",
  "&backepsilon;": "Ï¶",
  "&backprime;": "âµ",
  "&backsim;": "â½",
  "&backsimeq;": "â",
  "&barvee;": "â½",
  "&barwed;": "â",
  "&barwedge;": "â",
  "&bbrk;": "âµ",
  "&bbrktbrk;": "â¶",
  "&bcong;": "â",
  "&bcy;": "Ð±",
  "&bdquo;": "â",
  "&becaus;": "âµ",
  "&because;": "âµ",
  "&bemptyv;": "â¦°",
  "&bepsi;": "Ï¶",
  "&bernou;": "â¬",
  "&beta;": "Î²",
  "&beth;": "â¶",
  "&between;": "â¬",
  "&bfr;": "ð",
  "&bigcap;": "â",
  "&bigcirc;": "â¯",
  "&bigcup;": "â",
  "&bigodot;": "â¨",
  "&bigoplus;": "â¨",
  "&bigotimes;": "â¨",
  "&bigsqcup;": "â¨",
  "&bigstar;": "â",
  "&bigtriangledown;": "â½",
  "&bigtriangleup;": "â³",
  "&biguplus;": "â¨",
  "&bigvee;": "â",
  "&bigwedge;": "â",
  "&bkarow;": "â¤",
  "&blacklozenge;": "â§«",
  "&blacksquare;": "âª",
  "&blacktriangle;": "â´",
  "&blacktriangledown;": "â¾",
  "&blacktriangleleft;": "â",
  "&blacktriangleright;": "â¸",
  "&blank;": "â£",
  "&blk12;": "â",
  "&blk14;": "â",
  "&blk34;": "â",
  "&block;": "â",
  "&bne;": "=â¥",
  "&bnequiv;": "â¡â¥",
  "&bnot;": "â",
  "&bopf;": "ð",
  "&bot;": "â¥",
  "&bottom;": "â¥",
  "&bowtie;": "â",
  "&boxDL;": "â",
  "&boxDR;": "â",
  "&boxDl;": "â",
  "&boxDr;": "â",
  "&boxH;": "â",
  "&boxHD;": "â¦",
  "&boxHU;": "â©",
  "&boxHd;": "â¤",
  "&boxHu;": "â§",
  "&boxUL;": "â",
  "&boxUR;": "â",
  "&boxUl;": "â",
  "&boxUr;": "â",
  "&boxV;": "â",
  "&boxVH;": "â¬",
  "&boxVL;": "â£",
  "&boxVR;": "â ",
  "&boxVh;": "â«",
  "&boxVl;": "â¢",
  "&boxVr;": "â",
  "&boxbox;": "â§",
  "&boxdL;": "â",
  "&boxdR;": "â",
  "&boxdl;": "â",
  "&boxdr;": "â",
  "&boxh;": "â",
  "&boxhD;": "â¥",
  "&boxhU;": "â¨",
  "&boxhd;": "â¬",
  "&boxhu;": "â´",
  "&boxminus;": "â",
  "&boxplus;": "â",
  "&boxtimes;": "â ",
  "&boxuL;": "â",
  "&boxuR;": "â",
  "&boxul;": "â",
  "&boxur;": "â",
  "&boxv;": "â",
  "&boxvH;": "âª",
  "&boxvL;": "â¡",
  "&boxvR;": "â",
  "&boxvh;": "â¼",
  "&boxvl;": "â¤",
  "&boxvr;": "â",
  "&bprime;": "âµ",
  "&breve;": "Ë",
  "&brvbar": "Â¦",
  "&brvbar;": "Â¦",
  "&bscr;": "ð·",
  "&bsemi;": "â",
  "&bsim;": "â½",
  "&bsime;": "â",
  "&bsol;": "\\",
  "&bsolb;": "â§",
  "&bsolhsub;": "â",
  "&bull;": "â¢",
  "&bullet;": "â¢",
  "&bump;": "â",
  "&bumpE;": "âª®",
  "&bumpe;": "â",
  "&bumpeq;": "â",
  "&cacute;": "Ä",
  "&cap;": "â©",
  "&capand;": "â©",
  "&capbrcup;": "â©",
  "&capcap;": "â©",
  "&capcup;": "â©",
  "&capdot;": "â©",
  "&caps;": "â©ï¸",
  "&caret;": "â",
  "&caron;": "Ë",
  "&ccaps;": "â©",
  "&ccaron;": "Ä",
  "&ccedil": "Ã§",
  "&ccedil;": "Ã§",
  "&ccirc;": "Ä",
  "&ccups;": "â©",
  "&ccupssm;": "â©",
  "&cdot;": "Ä",
  "&cedil": "Â¸",
  "&cedil;": "Â¸",
  "&cemptyv;": "â¦²",
  "&cent": "Â¢",
  "&cent;": "Â¢",
  "&centerdot;": "Â·",
  "&cfr;": "ð ",
  "&chcy;": "Ñ",
  "&check;": "â",
  "&checkmark;": "â",
  "&chi;": "Ï",
  "&cir;": "â",
  "&cirE;": "â§",
  "&circ;": "Ë",
  "&circeq;": "â",
  "&circlearrowleft;": "âº",
  "&circlearrowright;": "â»",
  "&circledR;": "Â®",
  "&circledS;": "â",
  "&circledast;": "â",
  "&circledcirc;": "â",
  "&circleddash;": "â",
  "&cire;": "â",
  "&cirfnint;": "â¨",
  "&cirmid;": "â«¯",
  "&cirscir;": "â§",
  "&clubs;": "â£",
  "&clubsuit;": "â£",
  "&colon;": ":",
  "&colone;": "â",
  "&coloneq;": "â",
  "&comma;": ",",
  "&commat;": "@",
  "&comp;": "â",
  "&compfn;": "â",
  "&complement;": "â",
  "&complexes;": "â",
  "&cong;": "â",
  "&congdot;": "â©­",
  "&conint;": "â®",
  "&copf;": "ð",
  "&coprod;": "â",
  "&copy": "Â©",
  "&copy;": "Â©",
  "&copysr;": "â",
  "&crarr;": "âµ",
  "&cross;": "â",
  "&cscr;": "ð¸",
  "&csub;": "â«",
  "&csube;": "â«",
  "&csup;": "â«",
  "&csupe;": "â«",
  "&ctdot;": "â¯",
  "&cudarrl;": "â¤¸",
  "&cudarrr;": "â¤µ",
  "&cuepr;": "â",
  "&cuesc;": "â",
  "&cularr;": "â¶",
  "&cularrp;": "â¤½",
  "&cup;": "âª",
  "&cupbrcap;": "â©",
  "&cupcap;": "â©",
  "&cupcup;": "â©",
  "&cupdot;": "â",
  "&cupor;": "â©",
  "&cups;": "âªï¸",
  "&curarr;": "â·",
  "&curarrm;": "â¤¼",
  "&curlyeqprec;": "â",
  "&curlyeqsucc;": "â",
  "&curlyvee;": "â",
  "&curlywedge;": "â",
  "&curren": "Â¤",
  "&curren;": "Â¤",
  "&curvearrowleft;": "â¶",
  "&curvearrowright;": "â·",
  "&cuvee;": "â",
  "&cuwed;": "â",
  "&cwconint;": "â²",
  "&cwint;": "â±",
  "&cylcty;": "â­",
  "&dArr;": "â",
  "&dHar;": "â¥¥",
  "&dagger;": "â ",
  "&daleth;": "â¸",
  "&darr;": "â",
  "&dash;": "â",
  "&dashv;": "â£",
  "&dbkarow;": "â¤",
  "&dblac;": "Ë",
  "&dcaron;": "Ä",
  "&dcy;": "Ð´",
  "&dd;": "â",
  "&ddagger;": "â¡",
  "&ddarr;": "â",
  "&ddotseq;": "â©·",
  "&deg": "Â°",
  "&deg;": "Â°",
  "&delta;": "Î´",
  "&demptyv;": "â¦±",
  "&dfisht;": "â¥¿",
  "&dfr;": "ð¡",
  "&dharl;": "â",
  "&dharr;": "â",
  "&diam;": "â",
  "&diamond;": "â",
  "&diamondsuit;": "â¦",
  "&diams;": "â¦",
  "&die;": "Â¨",
  "&digamma;": "Ï",
  "&disin;": "â²",
  "&div;": "Ã·",
  "&divide": "Ã·",
  "&divide;": "Ã·",
  "&divideontimes;": "â",
  "&divonx;": "â",
  "&djcy;": "Ñ",
  "&dlcorn;": "â",
  "&dlcrop;": "â",
  "&dollar;": "$",
  "&dopf;": "ð",
  "&dot;": "Ë",
  "&doteq;": "â",
  "&doteqdot;": "â",
  "&dotminus;": "â¸",
  "&dotplus;": "â",
  "&dotsquare;": "â¡",
  "&doublebarwedge;": "â",
  "&downarrow;": "â",
  "&downdownarrows;": "â",
  "&downharpoonleft;": "â",
  "&downharpoonright;": "â",
  "&drbkarow;": "â¤",
  "&drcorn;": "â",
  "&drcrop;": "â",
  "&dscr;": "ð¹",
  "&dscy;": "Ñ",
  "&dsol;": "â§¶",
  "&dstrok;": "Ä",
  "&dtdot;": "â±",
  "&dtri;": "â¿",
  "&dtrif;": "â¾",
  "&duarr;": "âµ",
  "&duhar;": "â¥¯",
  "&dwangle;": "â¦¦",
  "&dzcy;": "Ñ",
  "&dzigrarr;": "â¿",
  "&eDDot;": "â©·",
  "&eDot;": "â",
  "&eacute": "Ã©",
  "&eacute;": "Ã©",
  "&easter;": "â©®",
  "&ecaron;": "Ä",
  "&ecir;": "â",
  "&ecirc": "Ãª",
  "&ecirc;": "Ãª",
  "&ecolon;": "â",
  "&ecy;": "Ñ",
  "&edot;": "Ä",
  "&ee;": "â",
  "&efDot;": "â",
  "&efr;": "ð¢",
  "&eg;": "âª",
  "&egrave": "Ã¨",
  "&egrave;": "Ã¨",
  "&egs;": "âª",
  "&egsdot;": "âª",
  "&el;": "âª",
  "&elinters;": "â§",
  "&ell;": "â",
  "&els;": "âª",
  "&elsdot;": "âª",
  "&emacr;": "Ä",
  "&empty;": "â",
  "&emptyset;": "â",
  "&emptyv;": "â",
  "&emsp13;": "â",
  "&emsp14;": "â",
  "&emsp;": "â",
  "&eng;": "Å",
  "&ensp;": "â",
  "&eogon;": "Ä",
  "&eopf;": "ð",
  "&epar;": "â",
  "&eparsl;": "â§£",
  "&eplus;": "â©±",
  "&epsi;": "Îµ",
  "&epsilon;": "Îµ",
  "&epsiv;": "Ïµ",
  "&eqcirc;": "â",
  "&eqcolon;": "â",
  "&eqsim;": "â",
  "&eqslantgtr;": "âª",
  "&eqslantless;": "âª",
  "&equals;": "=",
  "&equest;": "â",
  "&equiv;": "â¡",
  "&equivDD;": "â©¸",
  "&eqvparsl;": "â§¥",
  "&erDot;": "â",
  "&erarr;": "â¥±",
  "&escr;": "â¯",
  "&esdot;": "â",
  "&esim;": "â",
  "&eta;": "Î·",
  "&eth": "Ã°",
  "&eth;": "Ã°",
  "&euml": "Ã«",
  "&euml;": "Ã«",
  "&euro;": "â¬",
  "&excl;": "!",
  "&exist;": "â",
  "&expectation;": "â°",
  "&exponentiale;": "â",
  "&fallingdotseq;": "â",
  "&fcy;": "Ñ",
  "&female;": "â",
  "&ffilig;": "ï¬",
  "&fflig;": "ï¬",
  "&ffllig;": "ï¬",
  "&ffr;": "ð£",
  "&filig;": "ï¬",
  "&fjlig;": "fj",
  "&flat;": "â­",
  "&fllig;": "ï¬",
  "&fltns;": "â±",
  "&fnof;": "Æ",
  "&fopf;": "ð",
  "&forall;": "â",
  "&fork;": "â",
  "&forkv;": "â«",
  "&fpartint;": "â¨",
  "&frac12": "Â½",
  "&frac12;": "Â½",
  "&frac13;": "â",
  "&frac14": "Â¼",
  "&frac14;": "Â¼",
  "&frac15;": "â",
  "&frac16;": "â",
  "&frac18;": "â",
  "&frac23;": "â",
  "&frac25;": "â",
  "&frac34": "Â¾",
  "&frac34;": "Â¾",
  "&frac35;": "â",
  "&frac38;": "â",
  "&frac45;": "â",
  "&frac56;": "â",
  "&frac58;": "â",
  "&frac78;": "â",
  "&frasl;": "â",
  "&frown;": "â¢",
  "&fscr;": "ð»",
  "&gE;": "â§",
  "&gEl;": "âª",
  "&gacute;": "Çµ",
  "&gamma;": "Î³",
  "&gammad;": "Ï",
  "&gap;": "âª",
  "&gbreve;": "Ä",
  "&gcirc;": "Ä",
  "&gcy;": "Ð³",
  "&gdot;": "Ä¡",
  "&ge;": "â¥",
  "&gel;": "â",
  "&geq;": "â¥",
  "&geqq;": "â§",
  "&geqslant;": "â©¾",
  "&ges;": "â©¾",
  "&gescc;": "âª©",
  "&gesdot;": "âª",
  "&gesdoto;": "âª",
  "&gesdotol;": "âª",
  "&gesl;": "âï¸",
  "&gesles;": "âª",
  "&gfr;": "ð¤",
  "&gg;": "â«",
  "&ggg;": "â",
  "&gimel;": "â·",
  "&gjcy;": "Ñ",
  "&gl;": "â·",
  "&glE;": "âª",
  "&gla;": "âª¥",
  "&glj;": "âª¤",
  "&gnE;": "â©",
  "&gnap;": "âª",
  "&gnapprox;": "âª",
  "&gne;": "âª",
  "&gneq;": "âª",
  "&gneqq;": "â©",
  "&gnsim;": "â§",
  "&gopf;": "ð",
  "&grave;": "`",
  "&gscr;": "â",
  "&gsim;": "â³",
  "&gsime;": "âª",
  "&gsiml;": "âª",
  "&gt": ">",
  "&gt;": ">",
  "&gtcc;": "âª§",
  "&gtcir;": "â©º",
  "&gtdot;": "â",
  "&gtlPar;": "â¦",
  "&gtquest;": "â©¼",
  "&gtrapprox;": "âª",
  "&gtrarr;": "â¥¸",
  "&gtrdot;": "â",
  "&gtreqless;": "â",
  "&gtreqqless;": "âª",
  "&gtrless;": "â·",
  "&gtrsim;": "â³",
  "&gvertneqq;": "â©ï¸",
  "&gvnE;": "â©ï¸",
  "&hArr;": "â",
  "&hairsp;": "â",
  "&half;": "Â½",
  "&hamilt;": "â",
  "&hardcy;": "Ñ",
  "&harr;": "â",
  "&harrcir;": "â¥",
  "&harrw;": "â­",
  "&hbar;": "â",
  "&hcirc;": "Ä¥",
  "&hearts;": "â¥",
  "&heartsuit;": "â¥",
  "&hellip;": "â¦",
  "&hercon;": "â¹",
  "&hfr;": "ð¥",
  "&hksearow;": "â¤¥",
  "&hkswarow;": "â¤¦",
  "&hoarr;": "â¿",
  "&homtht;": "â»",
  "&hookleftarrow;": "â©",
  "&hookrightarrow;": "âª",
  "&hopf;": "ð",
  "&horbar;": "â",
  "&hscr;": "ð½",
  "&hslash;": "â",
  "&hstrok;": "Ä§",
  "&hybull;": "â",
  "&hyphen;": "â",
  "&iacute": "Ã­",
  "&iacute;": "Ã­",
  "&ic;": "â£",
  "&icirc": "Ã®",
  "&icirc;": "Ã®",
  "&icy;": "Ð¸",
  "&iecy;": "Ðµ",
  "&iexcl": "Â¡",
  "&iexcl;": "Â¡",
  "&iff;": "â",
  "&ifr;": "ð¦",
  "&igrave": "Ã¬",
  "&igrave;": "Ã¬",
  "&ii;": "â",
  "&iiiint;": "â¨",
  "&iiint;": "â­",
  "&iinfin;": "â§",
  "&iiota;": "â©",
  "&ijlig;": "Ä³",
  "&imacr;": "Ä«",
  "&image;": "â",
  "&imagline;": "â",
  "&imagpart;": "â",
  "&imath;": "Ä±",
  "&imof;": "â·",
  "&imped;": "Æµ",
  "&in;": "â",
  "&incare;": "â",
  "&infin;": "â",
  "&infintie;": "â§",
  "&inodot;": "Ä±",
  "&int;": "â«",
  "&intcal;": "âº",
  "&integers;": "â¤",
  "&intercal;": "âº",
  "&intlarhk;": "â¨",
  "&intprod;": "â¨¼",
  "&iocy;": "Ñ",
  "&iogon;": "Ä¯",
  "&iopf;": "ð",
  "&iota;": "Î¹",
  "&iprod;": "â¨¼",
  "&iquest": "Â¿",
  "&iquest;": "Â¿",
  "&iscr;": "ð¾",
  "&isin;": "â",
  "&isinE;": "â¹",
  "&isindot;": "âµ",
  "&isins;": "â´",
  "&isinsv;": "â³",
  "&isinv;": "â",
  "&it;": "â¢",
  "&itilde;": "Ä©",
  "&iukcy;": "Ñ",
  "&iuml": "Ã¯",
  "&iuml;": "Ã¯",
  "&jcirc;": "Äµ",
  "&jcy;": "Ð¹",
  "&jfr;": "ð§",
  "&jmath;": "È·",
  "&jopf;": "ð",
  "&jscr;": "ð¿",
  "&jsercy;": "Ñ",
  "&jukcy;": "Ñ",
  "&kappa;": "Îº",
  "&kappav;": "Ï°",
  "&kcedil;": "Ä·",
  "&kcy;": "Ðº",
  "&kfr;": "ð¨",
  "&kgreen;": "Ä¸",
  "&khcy;": "Ñ",
  "&kjcy;": "Ñ",
  "&kopf;": "ð",
  "&kscr;": "ð",
  "&lAarr;": "â",
  "&lArr;": "â",
  "&lAtail;": "â¤",
  "&lBarr;": "â¤",
  "&lE;": "â¦",
  "&lEg;": "âª",
  "&lHar;": "â¥¢",
  "&lacute;": "Äº",
  "&laemptyv;": "â¦´",
  "&lagran;": "â",
  "&lambda;": "Î»",
  "&lang;": "â¨",
  "&langd;": "â¦",
  "&langle;": "â¨",
  "&lap;": "âª",
  "&laquo": "Â«",
  "&laquo;": "Â«",
  "&larr;": "â",
  "&larrb;": "â¤",
  "&larrbfs;": "â¤",
  "&larrfs;": "â¤",
  "&larrhk;": "â©",
  "&larrlp;": "â«",
  "&larrpl;": "â¤¹",
  "&larrsim;": "â¥³",
  "&larrtl;": "â¢",
  "&lat;": "âª«",
  "&latail;": "â¤",
  "&late;": "âª­",
  "&lates;": "âª­ï¸",
  "&lbarr;": "â¤",
  "&lbbrk;": "â²",
  "&lbrace;": "{",
  "&lbrack;": "[",
  "&lbrke;": "â¦",
  "&lbrksld;": "â¦",
  "&lbrkslu;": "â¦",
  "&lcaron;": "Ä¾",
  "&lcedil;": "Ä¼",
  "&lceil;": "â",
  "&lcub;": "{",
  "&lcy;": "Ð»",
  "&ldca;": "â¤¶",
  "&ldquo;": "â",
  "&ldquor;": "â",
  "&ldrdhar;": "â¥§",
  "&ldrushar;": "â¥",
  "&ldsh;": "â²",
  "&le;": "â¤",
  "&leftarrow;": "â",
  "&leftarrowtail;": "â¢",
  "&leftharpoondown;": "â½",
  "&leftharpoonup;": "â¼",
  "&leftleftarrows;": "â",
  "&leftrightarrow;": "â",
  "&leftrightarrows;": "â",
  "&leftrightharpoons;": "â",
  "&leftrightsquigarrow;": "â­",
  "&leftthreetimes;": "â",
  "&leg;": "â",
  "&leq;": "â¤",
  "&leqq;": "â¦",
  "&leqslant;": "â©½",
  "&les;": "â©½",
  "&lescc;": "âª¨",
  "&lesdot;": "â©¿",
  "&lesdoto;": "âª",
  "&lesdotor;": "âª",
  "&lesg;": "âï¸",
  "&lesges;": "âª",
  "&lessapprox;": "âª",
  "&lessdot;": "â",
  "&lesseqgtr;": "â",
  "&lesseqqgtr;": "âª",
  "&lessgtr;": "â¶",
  "&lesssim;": "â²",
  "&lfisht;": "â¥¼",
  "&lfloor;": "â",
  "&lfr;": "ð©",
  "&lg;": "â¶",
  "&lgE;": "âª",
  "&lhard;": "â½",
  "&lharu;": "â¼",
  "&lharul;": "â¥ª",
  "&lhblk;": "â",
  "&ljcy;": "Ñ",
  "&ll;": "âª",
  "&llarr;": "â",
  "&llcorner;": "â",
  "&llhard;": "â¥«",
  "&lltri;": "âº",
  "&lmidot;": "Å",
  "&lmoust;": "â°",
  "&lmoustache;": "â°",
  "&lnE;": "â¨",
  "&lnap;": "âª",
  "&lnapprox;": "âª",
  "&lne;": "âª",
  "&lneq;": "âª",
  "&lneqq;": "â¨",
  "&lnsim;": "â¦",
  "&loang;": "â¬",
  "&loarr;": "â½",
  "&lobrk;": "â¦",
  "&longleftarrow;": "âµ",
  "&longleftrightarrow;": "â·",
  "&longmapsto;": "â¼",
  "&longrightarrow;": "â¶",
  "&looparrowleft;": "â«",
  "&looparrowright;": "â¬",
  "&lopar;": "â¦",
  "&lopf;": "ð",
  "&loplus;": "â¨­",
  "&lotimes;": "â¨´",
  "&lowast;": "â",
  "&lowbar;": "_",
  "&loz;": "â",
  "&lozenge;": "â",
  "&lozf;": "â§«",
  "&lpar;": "(",
  "&lparlt;": "â¦",
  "&lrarr;": "â",
  "&lrcorner;": "â",
  "&lrhar;": "â",
  "&lrhard;": "â¥­",
  "&lrm;": "â",
  "&lrtri;": "â¿",
  "&lsaquo;": "â¹",
  "&lscr;": "ð",
  "&lsh;": "â°",
  "&lsim;": "â²",
  "&lsime;": "âª",
  "&lsimg;": "âª",
  "&lsqb;": "[",
  "&lsquo;": "â",
  "&lsquor;": "â",
  "&lstrok;": "Å",
  "&lt": "<",
  "&lt;": "<",
  "&ltcc;": "âª¦",
  "&ltcir;": "â©¹",
  "&ltdot;": "â",
  "&lthree;": "â",
  "&ltimes;": "â",
  "&ltlarr;": "â¥¶",
  "&ltquest;": "â©»",
  "&ltrPar;": "â¦",
  "&ltri;": "â",
  "&ltrie;": "â´",
  "&ltrif;": "â",
  "&lurdshar;": "â¥",
  "&luruhar;": "â¥¦",
  "&lvertneqq;": "â¨ï¸",
  "&lvnE;": "â¨ï¸",
  "&mDDot;": "âº",
  "&macr": "Â¯",
  "&macr;": "Â¯",
  "&male;": "â",
  "&malt;": "â ",
  "&maltese;": "â ",
  "&map;": "â¦",
  "&mapsto;": "â¦",
  "&mapstodown;": "â§",
  "&mapstoleft;": "â¤",
  "&mapstoup;": "â¥",
  "&marker;": "â®",
  "&mcomma;": "â¨©",
  "&mcy;": "Ð¼",
  "&mdash;": "â",
  "&measuredangle;": "â¡",
  "&mfr;": "ðª",
  "&mho;": "â§",
  "&micro": "Âµ",
  "&micro;": "Âµ",
  "&mid;": "â£",
  "&midast;": "*",
  "&midcir;": "â«°",
  "&middot": "Â·",
  "&middot;": "Â·",
  "&minus;": "â",
  "&minusb;": "â",
  "&minusd;": "â¸",
  "&minusdu;": "â¨ª",
  "&mlcp;": "â«",
  "&mldr;": "â¦",
  "&mnplus;": "â",
  "&models;": "â§",
  "&mopf;": "ð",
  "&mp;": "â",
  "&mscr;": "ð",
  "&mstpos;": "â¾",
  "&mu;": "Î¼",
  "&multimap;": "â¸",
  "&mumap;": "â¸",
  "&nGg;": "âÌ¸",
  "&nGt;": "â«â",
  "&nGtv;": "â«Ì¸",
  "&nLeftarrow;": "â",
  "&nLeftrightarrow;": "â",
  "&nLl;": "âÌ¸",
  "&nLt;": "âªâ",
  "&nLtv;": "âªÌ¸",
  "&nRightarrow;": "â",
  "&nVDash;": "â¯",
  "&nVdash;": "â®",
  "&nabla;": "â",
  "&nacute;": "Å",
  "&nang;": "â â",
  "&nap;": "â",
  "&napE;": "â©°Ì¸",
  "&napid;": "âÌ¸",
  "&napos;": "Å",
  "&napprox;": "â",
  "&natur;": "â®",
  "&natural;": "â®",
  "&naturals;": "â",
  "&nbsp": "Â ",
  "&nbsp;": "Â ",
  "&nbump;": "âÌ¸",
  "&nbumpe;": "âÌ¸",
  "&ncap;": "â©",
  "&ncaron;": "Å",
  "&ncedil;": "Å",
  "&ncong;": "â",
  "&ncongdot;": "â©­Ì¸",
  "&ncup;": "â©",
  "&ncy;": "Ð½",
  "&ndash;": "â",
  "&ne;": "â ",
  "&neArr;": "â",
  "&nearhk;": "â¤¤",
  "&nearr;": "â",
  "&nearrow;": "â",
  "&nedot;": "âÌ¸",
  "&nequiv;": "â¢",
  "&nesear;": "â¤¨",
  "&nesim;": "âÌ¸",
  "&nexist;": "â",
  "&nexists;": "â",
  "&nfr;": "ð«",
  "&ngE;": "â§Ì¸",
  "&nge;": "â±",
  "&ngeq;": "â±",
  "&ngeqq;": "â§Ì¸",
  "&ngeqslant;": "â©¾Ì¸",
  "&nges;": "â©¾Ì¸",
  "&ngsim;": "âµ",
  "&ngt;": "â¯",
  "&ngtr;": "â¯",
  "&nhArr;": "â",
  "&nharr;": "â®",
  "&nhpar;": "â«²",
  "&ni;": "â",
  "&nis;": "â¼",
  "&nisd;": "âº",
  "&niv;": "â",
  "&njcy;": "Ñ",
  "&nlArr;": "â",
  "&nlE;": "â¦Ì¸",
  "&nlarr;": "â",
  "&nldr;": "â¥",
  "&nle;": "â°",
  "&nleftarrow;": "â",
  "&nleftrightarrow;": "â®",
  "&nleq;": "â°",
  "&nleqq;": "â¦Ì¸",
  "&nleqslant;": "â©½Ì¸",
  "&nles;": "â©½Ì¸",
  "&nless;": "â®",
  "&nlsim;": "â´",
  "&nlt;": "â®",
  "&nltri;": "âª",
  "&nltrie;": "â¬",
  "&nmid;": "â¤",
  "&nopf;": "ð",
  "&not": "Â¬",
  "&not;": "Â¬",
  "&notin;": "â",
  "&notinE;": "â¹Ì¸",
  "&notindot;": "âµÌ¸",
  "&notinva;": "â",
  "&notinvb;": "â·",
  "&notinvc;": "â¶",
  "&notni;": "â",
  "&notniva;": "â",
  "&notnivb;": "â¾",
  "&notnivc;": "â½",
  "&npar;": "â¦",
  "&nparallel;": "â¦",
  "&nparsl;": "â«½â¥",
  "&npart;": "âÌ¸",
  "&npolint;": "â¨",
  "&npr;": "â",
  "&nprcue;": "â ",
  "&npre;": "âª¯Ì¸",
  "&nprec;": "â",
  "&npreceq;": "âª¯Ì¸",
  "&nrArr;": "â",
  "&nrarr;": "â",
  "&nrarrc;": "â¤³Ì¸",
  "&nrarrw;": "âÌ¸",
  "&nrightarrow;": "â",
  "&nrtri;": "â«",
  "&nrtrie;": "â­",
  "&nsc;": "â",
  "&nsccue;": "â¡",
  "&nsce;": "âª°Ì¸",
  "&nscr;": "ð",
  "&nshortmid;": "â¤",
  "&nshortparallel;": "â¦",
  "&nsim;": "â",
  "&nsime;": "â",
  "&nsimeq;": "â",
  "&nsmid;": "â¤",
  "&nspar;": "â¦",
  "&nsqsube;": "â¢",
  "&nsqsupe;": "â£",
  "&nsub;": "â",
  "&nsubE;": "â«Ì¸",
  "&nsube;": "â",
  "&nsubset;": "ââ",
  "&nsubseteq;": "â",
  "&nsubseteqq;": "â«Ì¸",
  "&nsucc;": "â",
  "&nsucceq;": "âª°Ì¸",
  "&nsup;": "â",
  "&nsupE;": "â«Ì¸",
  "&nsupe;": "â",
  "&nsupset;": "ââ",
  "&nsupseteq;": "â",
  "&nsupseteqq;": "â«Ì¸",
  "&ntgl;": "â¹",
  "&ntilde": "Ã±",
  "&ntilde;": "Ã±",
  "&ntlg;": "â¸",
  "&ntriangleleft;": "âª",
  "&ntrianglelefteq;": "â¬",
  "&ntriangleright;": "â«",
  "&ntrianglerighteq;": "â­",
  "&nu;": "Î½",
  "&num;": "#",
  "&numero;": "â",
  "&numsp;": "â",
  "&nvDash;": "â­",
  "&nvHarr;": "â¤",
  "&nvap;": "ââ",
  "&nvdash;": "â¬",
  "&nvge;": "â¥â",
  "&nvgt;": ">â",
  "&nvinfin;": "â§",
  "&nvlArr;": "â¤",
  "&nvle;": "â¤â",
  "&nvlt;": "<â",
  "&nvltrie;": "â´â",
  "&nvrArr;": "â¤",
  "&nvrtrie;": "âµâ",
  "&nvsim;": "â¼â",
  "&nwArr;": "â",
  "&nwarhk;": "â¤£",
  "&nwarr;": "â",
  "&nwarrow;": "â",
  "&nwnear;": "â¤§",
  "&oS;": "â",
  "&oacute": "Ã³",
  "&oacute;": "Ã³",
  "&oast;": "â",
  "&ocir;": "â",
  "&ocirc": "Ã´",
  "&ocirc;": "Ã´",
  "&ocy;": "Ð¾",
  "&odash;": "â",
  "&odblac;": "Å",
  "&odiv;": "â¨¸",
  "&odot;": "â",
  "&odsold;": "â¦¼",
  "&oelig;": "Å",
  "&ofcir;": "â¦¿",
  "&ofr;": "ð¬",
  "&ogon;": "Ë",
  "&ograve": "Ã²",
  "&ograve;": "Ã²",
  "&ogt;": "â§",
  "&ohbar;": "â¦µ",
  "&ohm;": "Î©",
  "&oint;": "â®",
  "&olarr;": "âº",
  "&olcir;": "â¦¾",
  "&olcross;": "â¦»",
  "&oline;": "â¾",
  "&olt;": "â§",
  "&omacr;": "Å",
  "&omega;": "Ï",
  "&omicron;": "Î¿",
  "&omid;": "â¦¶",
  "&ominus;": "â",
  "&oopf;": "ð ",
  "&opar;": "â¦·",
  "&operp;": "â¦¹",
  "&oplus;": "â",
  "&or;": "â¨",
  "&orarr;": "â»",
  "&ord;": "â©",
  "&order;": "â´",
  "&orderof;": "â´",
  "&ordf": "Âª",
  "&ordf;": "Âª",
  "&ordm": "Âº",
  "&ordm;": "Âº",
  "&origof;": "â¶",
  "&oror;": "â©",
  "&orslope;": "â©",
  "&orv;": "â©",
  "&oscr;": "â´",
  "&oslash": "Ã¸",
  "&oslash;": "Ã¸",
  "&osol;": "â",
  "&otilde": "Ãµ",
  "&otilde;": "Ãµ",
  "&otimes;": "â",
  "&otimesas;": "â¨¶",
  "&ouml": "Ã¶",
  "&ouml;": "Ã¶",
  "&ovbar;": "â½",
  "&par;": "â¥",
  "&para": "Â¶",
  "&para;": "Â¶",
  "&parallel;": "â¥",
  "&parsim;": "â«³",
  "&parsl;": "â«½",
  "&part;": "â",
  "&pcy;": "Ð¿",
  "&percnt;": "%",
  "&period;": ".",
  "&permil;": "â°",
  "&perp;": "â¥",
  "&pertenk;": "â±",
  "&pfr;": "ð­",
  "&phi;": "Ï",
  "&phiv;": "Ï",
  "&phmmat;": "â³",
  "&phone;": "â",
  "&pi;": "Ï",
  "&pitchfork;": "â",
  "&piv;": "Ï",
  "&planck;": "â",
  "&planckh;": "â",
  "&plankv;": "â",
  "&plus;": "+",
  "&plusacir;": "â¨£",
  "&plusb;": "â",
  "&pluscir;": "â¨¢",
  "&plusdo;": "â",
  "&plusdu;": "â¨¥",
  "&pluse;": "â©²",
  "&plusmn": "Â±",
  "&plusmn;": "Â±",
  "&plussim;": "â¨¦",
  "&plustwo;": "â¨§",
  "&pm;": "Â±",
  "&pointint;": "â¨",
  "&popf;": "ð¡",
  "&pound": "Â£",
  "&pound;": "Â£",
  "&pr;": "âº",
  "&prE;": "âª³",
  "&prap;": "âª·",
  "&prcue;": "â¼",
  "&pre;": "âª¯",
  "&prec;": "âº",
  "&precapprox;": "âª·",
  "&preccurlyeq;": "â¼",
  "&preceq;": "âª¯",
  "&precnapprox;": "âª¹",
  "&precneqq;": "âªµ",
  "&precnsim;": "â¨",
  "&precsim;": "â¾",
  "&prime;": "â²",
  "&primes;": "â",
  "&prnE;": "âªµ",
  "&prnap;": "âª¹",
  "&prnsim;": "â¨",
  "&prod;": "â",
  "&profalar;": "â®",
  "&profline;": "â",
  "&profsurf;": "â",
  "&prop;": "â",
  "&propto;": "â",
  "&prsim;": "â¾",
  "&prurel;": "â°",
  "&pscr;": "ð",
  "&psi;": "Ï",
  "&puncsp;": "â",
  "&qfr;": "ð®",
  "&qint;": "â¨",
  "&qopf;": "ð¢",
  "&qprime;": "â",
  "&qscr;": "ð",
  "&quaternions;": "â",
  "&quatint;": "â¨",
  "&quest;": "?",
  "&questeq;": "â",
  "&quot": '"',
  "&quot;": '"',
  "&rAarr;": "â",
  "&rArr;": "â",
  "&rAtail;": "â¤",
  "&rBarr;": "â¤",
  "&rHar;": "â¥¤",
  "&race;": "â½Ì±",
  "&racute;": "Å",
  "&radic;": "â",
  "&raemptyv;": "â¦³",
  "&rang;": "â©",
  "&rangd;": "â¦",
  "&range;": "â¦¥",
  "&rangle;": "â©",
  "&raquo": "Â»",
  "&raquo;": "Â»",
  "&rarr;": "â",
  "&rarrap;": "â¥µ",
  "&rarrb;": "â¥",
  "&rarrbfs;": "â¤ ",
  "&rarrc;": "â¤³",
  "&rarrfs;": "â¤",
  "&rarrhk;": "âª",
  "&rarrlp;": "â¬",
  "&rarrpl;": "â¥",
  "&rarrsim;": "â¥´",
  "&rarrtl;": "â£",
  "&rarrw;": "â",
  "&ratail;": "â¤",
  "&ratio;": "â¶",
  "&rationals;": "â",
  "&rbarr;": "â¤",
  "&rbbrk;": "â³",
  "&rbrace;": "}",
  "&rbrack;": "]",
  "&rbrke;": "â¦",
  "&rbrksld;": "â¦",
  "&rbrkslu;": "â¦",
  "&rcaron;": "Å",
  "&rcedil;": "Å",
  "&rceil;": "â",
  "&rcub;": "}",
  "&rcy;": "Ñ",
  "&rdca;": "â¤·",
  "&rdldhar;": "â¥©",
  "&rdquo;": "â",
  "&rdquor;": "â",
  "&rdsh;": "â³",
  "&real;": "â",
  "&realine;": "â",
  "&realpart;": "â",
  "&reals;": "â",
  "&rect;": "â­",
  "&reg": "Â®",
  "&reg;": "Â®",
  "&rfisht;": "â¥½",
  "&rfloor;": "â",
  "&rfr;": "ð¯",
  "&rhard;": "â",
  "&rharu;": "â",
  "&rharul;": "â¥¬",
  "&rho;": "Ï",
  "&rhov;": "Ï±",
  "&rightarrow;": "â",
  "&rightarrowtail;": "â£",
  "&rightharpoondown;": "â",
  "&rightharpoonup;": "â",
  "&rightleftarrows;": "â",
  "&rightleftharpoons;": "â",
  "&rightrightarrows;": "â",
  "&rightsquigarrow;": "â",
  "&rightthreetimes;": "â",
  "&ring;": "Ë",
  "&risingdotseq;": "â",
  "&rlarr;": "â",
  "&rlhar;": "â",
  "&rlm;": "â",
  "&rmoust;": "â±",
  "&rmoustache;": "â±",
  "&rnmid;": "â«®",
  "&roang;": "â­",
  "&roarr;": "â¾",
  "&robrk;": "â§",
  "&ropar;": "â¦",
  "&ropf;": "ð£",
  "&roplus;": "â¨®",
  "&rotimes;": "â¨µ",
  "&rpar;": ")",
  "&rpargt;": "â¦",
  "&rppolint;": "â¨",
  "&rrarr;": "â",
  "&rsaquo;": "âº",
  "&rscr;": "ð",
  "&rsh;": "â±",
  "&rsqb;": "]",
  "&rsquo;": "â",
  "&rsquor;": "â",
  "&rthree;": "â",
  "&rtimes;": "â",
  "&rtri;": "â¹",
  "&rtrie;": "âµ",
  "&rtrif;": "â¸",
  "&rtriltri;": "â§",
  "&ruluhar;": "â¥¨",
  "&rx;": "â",
  "&sacute;": "Å",
  "&sbquo;": "â",
  "&sc;": "â»",
  "&scE;": "âª´",
  "&scap;": "âª¸",
  "&scaron;": "Å¡",
  "&sccue;": "â½",
  "&sce;": "âª°",
  "&scedil;": "Å",
  "&scirc;": "Å",
  "&scnE;": "âª¶",
  "&scnap;": "âªº",
  "&scnsim;": "â©",
  "&scpolint;": "â¨",
  "&scsim;": "â¿",
  "&scy;": "Ñ",
  "&sdot;": "â",
  "&sdotb;": "â¡",
  "&sdote;": "â©¦",
  "&seArr;": "â",
  "&searhk;": "â¤¥",
  "&searr;": "â",
  "&searrow;": "â",
  "&sect": "Â§",
  "&sect;": "Â§",
  "&semi;": ";",
  "&seswar;": "â¤©",
  "&setminus;": "â",
  "&setmn;": "â",
  "&sext;": "â¶",
  "&sfr;": "ð°",
  "&sfrown;": "â¢",
  "&sharp;": "â¯",
  "&shchcy;": "Ñ",
  "&shcy;": "Ñ",
  "&shortmid;": "â£",
  "&shortparallel;": "â¥",
  "&shy": "Â­",
  "&shy;": "Â­",
  "&sigma;": "Ï",
  "&sigmaf;": "Ï",
  "&sigmav;": "Ï",
  "&sim;": "â¼",
  "&simdot;": "â©ª",
  "&sime;": "â",
  "&simeq;": "â",
  "&simg;": "âª",
  "&simgE;": "âª ",
  "&siml;": "âª",
  "&simlE;": "âª",
  "&simne;": "â",
  "&simplus;": "â¨¤",
  "&simrarr;": "â¥²",
  "&slarr;": "â",
  "&smallsetminus;": "â",
  "&smashp;": "â¨³",
  "&smeparsl;": "â§¤",
  "&smid;": "â£",
  "&smile;": "â£",
  "&smt;": "âªª",
  "&smte;": "âª¬",
  "&smtes;": "âª¬ï¸",
  "&softcy;": "Ñ",
  "&sol;": "/",
  "&solb;": "â§",
  "&solbar;": "â¿",
  "&sopf;": "ð¤",
  "&spades;": "â ",
  "&spadesuit;": "â ",
  "&spar;": "â¥",
  "&sqcap;": "â",
  "&sqcaps;": "âï¸",
  "&sqcup;": "â",
  "&sqcups;": "âï¸",
  "&sqsub;": "â",
  "&sqsube;": "â",
  "&sqsubset;": "â",
  "&sqsubseteq;": "â",
  "&sqsup;": "â",
  "&sqsupe;": "â",
  "&sqsupset;": "â",
  "&sqsupseteq;": "â",
  "&squ;": "â¡",
  "&square;": "â¡",
  "&squarf;": "âª",
  "&squf;": "âª",
  "&srarr;": "â",
  "&sscr;": "ð",
  "&ssetmn;": "â",
  "&ssmile;": "â£",
  "&sstarf;": "â",
  "&star;": "â",
  "&starf;": "â",
  "&straightepsilon;": "Ïµ",
  "&straightphi;": "Ï",
  "&strns;": "Â¯",
  "&sub;": "â",
  "&subE;": "â«",
  "&subdot;": "âª½",
  "&sube;": "â",
  "&subedot;": "â«",
  "&submult;": "â«",
  "&subnE;": "â«",
  "&subne;": "â",
  "&subplus;": "âª¿",
  "&subrarr;": "â¥¹",
  "&subset;": "â",
  "&subseteq;": "â",
  "&subseteqq;": "â«",
  "&subsetneq;": "â",
  "&subsetneqq;": "â«",
  "&subsim;": "â«",
  "&subsub;": "â«",
  "&subsup;": "â«",
  "&succ;": "â»",
  "&succapprox;": "âª¸",
  "&succcurlyeq;": "â½",
  "&succeq;": "âª°",
  "&succnapprox;": "âªº",
  "&succneqq;": "âª¶",
  "&succnsim;": "â©",
  "&succsim;": "â¿",
  "&sum;": "â",
  "&sung;": "âª",
  "&sup1": "Â¹",
  "&sup1;": "Â¹",
  "&sup2": "Â²",
  "&sup2;": "Â²",
  "&sup3": "Â³",
  "&sup3;": "Â³",
  "&sup;": "â",
  "&supE;": "â«",
  "&supdot;": "âª¾",
  "&supdsub;": "â«",
  "&supe;": "â",
  "&supedot;": "â«",
  "&suphsol;": "â",
  "&suphsub;": "â«",
  "&suplarr;": "â¥»",
  "&supmult;": "â«",
  "&supnE;": "â«",
  "&supne;": "â",
  "&supplus;": "â«",
  "&supset;": "â",
  "&supseteq;": "â",
  "&supseteqq;": "â«",
  "&supsetneq;": "â",
  "&supsetneqq;": "â«",
  "&supsim;": "â«",
  "&supsub;": "â«",
  "&supsup;": "â«",
  "&swArr;": "â",
  "&swarhk;": "â¤¦",
  "&swarr;": "â",
  "&swarrow;": "â",
  "&swnwar;": "â¤ª",
  "&szlig": "Ã",
  "&szlig;": "Ã",
  "&target;": "â",
  "&tau;": "Ï",
  "&tbrk;": "â´",
  "&tcaron;": "Å¥",
  "&tcedil;": "Å£",
  "&tcy;": "Ñ",
  "&tdot;": "â",
  "&telrec;": "â",
  "&tfr;": "ð±",
  "&there4;": "â´",
  "&therefore;": "â´",
  "&theta;": "Î¸",
  "&thetasym;": "Ï",
  "&thetav;": "Ï",
  "&thickapprox;": "â",
  "&thicksim;": "â¼",
  "&thinsp;": "â",
  "&thkap;": "â",
  "&thksim;": "â¼",
  "&thorn": "Ã¾",
  "&thorn;": "Ã¾",
  "&tilde;": "Ë",
  "&times": "Ã",
  "&times;": "Ã",
  "&timesb;": "â ",
  "&timesbar;": "â¨±",
  "&timesd;": "â¨°",
  "&tint;": "â­",
  "&toea;": "â¤¨",
  "&top;": "â¤",
  "&topbot;": "â¶",
  "&topcir;": "â«±",
  "&topf;": "ð¥",
  "&topfork;": "â«",
  "&tosa;": "â¤©",
  "&tprime;": "â´",
  "&trade;": "â¢",
  "&triangle;": "âµ",
  "&triangledown;": "â¿",
  "&triangleleft;": "â",
  "&trianglelefteq;": "â´",
  "&triangleq;": "â",
  "&triangleright;": "â¹",
  "&trianglerighteq;": "âµ",
  "&tridot;": "â¬",
  "&trie;": "â",
  "&triminus;": "â¨º",
  "&triplus;": "â¨¹",
  "&trisb;": "â§",
  "&tritime;": "â¨»",
  "&trpezium;": "â¢",
  "&tscr;": "ð",
  "&tscy;": "Ñ",
  "&tshcy;": "Ñ",
  "&tstrok;": "Å§",
  "&twixt;": "â¬",
  "&twoheadleftarrow;": "â",
  "&twoheadrightarrow;": "â ",
  "&uArr;": "â",
  "&uHar;": "â¥£",
  "&uacute": "Ãº",
  "&uacute;": "Ãº",
  "&uarr;": "â",
  "&ubrcy;": "Ñ",
  "&ubreve;": "Å­",
  "&ucirc": "Ã»",
  "&ucirc;": "Ã»",
  "&ucy;": "Ñ",
  "&udarr;": "â",
  "&udblac;": "Å±",
  "&udhar;": "â¥®",
  "&ufisht;": "â¥¾",
  "&ufr;": "ð²",
  "&ugrave": "Ã¹",
  "&ugrave;": "Ã¹",
  "&uharl;": "â¿",
  "&uharr;": "â¾",
  "&uhblk;": "â",
  "&ulcorn;": "â",
  "&ulcorner;": "â",
  "&ulcrop;": "â",
  "&ultri;": "â¸",
  "&umacr;": "Å«",
  "&uml": "Â¨",
  "&uml;": "Â¨",
  "&uogon;": "Å³",
  "&uopf;": "ð¦",
  "&uparrow;": "â",
  "&updownarrow;": "â",
  "&upharpoonleft;": "â¿",
  "&upharpoonright;": "â¾",
  "&uplus;": "â",
  "&upsi;": "Ï",
  "&upsih;": "Ï",
  "&upsilon;": "Ï",
  "&upuparrows;": "â",
  "&urcorn;": "â",
  "&urcorner;": "â",
  "&urcrop;": "â",
  "&uring;": "Å¯",
  "&urtri;": "â¹",
  "&uscr;": "ð",
  "&utdot;": "â°",
  "&utilde;": "Å©",
  "&utri;": "âµ",
  "&utrif;": "â´",
  "&uuarr;": "â",
  "&uuml": "Ã¼",
  "&uuml;": "Ã¼",
  "&uwangle;": "â¦§",
  "&vArr;": "â",
  "&vBar;": "â«¨",
  "&vBarv;": "â«©",
  "&vDash;": "â¨",
  "&vangrt;": "â¦",
  "&varepsilon;": "Ïµ",
  "&varkappa;": "Ï°",
  "&varnothing;": "â",
  "&varphi;": "Ï",
  "&varpi;": "Ï",
  "&varpropto;": "â",
  "&varr;": "â",
  "&varrho;": "Ï±",
  "&varsigma;": "Ï",
  "&varsubsetneq;": "âï¸",
  "&varsubsetneqq;": "â«ï¸",
  "&varsupsetneq;": "âï¸",
  "&varsupsetneqq;": "â«ï¸",
  "&vartheta;": "Ï",
  "&vartriangleleft;": "â²",
  "&vartriangleright;": "â³",
  "&vcy;": "Ð²",
  "&vdash;": "â¢",
  "&vee;": "â¨",
  "&veebar;": "â»",
  "&veeeq;": "â",
  "&vellip;": "â®",
  "&verbar;": "|",
  "&vert;": "|",
  "&vfr;": "ð³",
  "&vltri;": "â²",
  "&vnsub;": "ââ",
  "&vnsup;": "ââ",
  "&vopf;": "ð§",
  "&vprop;": "â",
  "&vrtri;": "â³",
  "&vscr;": "ð",
  "&vsubnE;": "â«ï¸",
  "&vsubne;": "âï¸",
  "&vsupnE;": "â«ï¸",
  "&vsupne;": "âï¸",
  "&vzigzag;": "â¦",
  "&wcirc;": "Åµ",
  "&wedbar;": "â©",
  "&wedge;": "â§",
  "&wedgeq;": "â",
  "&weierp;": "â",
  "&wfr;": "ð´",
  "&wopf;": "ð¨",
  "&wp;": "â",
  "&wr;": "â",
  "&wreath;": "â",
  "&wscr;": "ð",
  "&xcap;": "â",
  "&xcirc;": "â¯",
  "&xcup;": "â",
  "&xdtri;": "â½",
  "&xfr;": "ðµ",
  "&xhArr;": "âº",
  "&xharr;": "â·",
  "&xi;": "Î¾",
  "&xlArr;": "â¸",
  "&xlarr;": "âµ",
  "&xmap;": "â¼",
  "&xnis;": "â»",
  "&xodot;": "â¨",
  "&xopf;": "ð©",
  "&xoplus;": "â¨",
  "&xotime;": "â¨",
  "&xrArr;": "â¹",
  "&xrarr;": "â¶",
  "&xscr;": "ð",
  "&xsqcup;": "â¨",
  "&xuplus;": "â¨",
  "&xutri;": "â³",
  "&xvee;": "â",
  "&xwedge;": "â",
  "&yacute": "Ã½",
  "&yacute;": "Ã½",
  "&yacy;": "Ñ",
  "&ycirc;": "Å·",
  "&ycy;": "Ñ",
  "&yen": "Â¥",
  "&yen;": "Â¥",
  "&yfr;": "ð¶",
  "&yicy;": "Ñ",
  "&yopf;": "ðª",
  "&yscr;": "ð",
  "&yucy;": "Ñ",
  "&yuml": "Ã¿",
  "&yuml;": "Ã¿",
  "&zacute;": "Åº",
  "&zcaron;": "Å¾",
  "&zcy;": "Ð·",
  "&zdot;": "Å¼",
  "&zeetrf;": "â¨",
  "&zeta;": "Î¶",
  "&zfr;": "ð·",
  "&zhcy;": "Ð¶",
  "&zigrarr;": "â",
  "&zopf;": "ð«",
  "&zscr;": "ð",
  "&zwj;": "â",
  "&zwnj;": "â"
};
var html_entities_default = htmlEntities;

// node_modules/postal-mime/src/text-format.js
function decodeHTMLEntities(str) {
  return str.replace(/&(#\d+|#x[a-f0-9]+|[a-z]+\d*);?/gi, (match, entity) => {
    if (typeof html_entities_default[match] === "string") {
      return html_entities_default[match];
    }
    if (entity.charAt(0) !== "#" || match.charAt(match.length - 1) !== ";") {
      return match;
    }
    let codePoint;
    if (entity.charAt(1) === "x") {
      codePoint = parseInt(entity.substr(2), 16);
    } else {
      codePoint = parseInt(entity.substr(1), 10);
    }
    var output = "";
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return "ï¿½";
    }
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  });
}
function escapeHtml(str) {
  return str.trim().replace(/[<>"'?&]/g, (c) => {
    let hex = c.charCodeAt(0).toString(16);
    if (hex.length < 2) {
      hex = "0" + hex;
    }
    return "&#x" + hex.toUpperCase() + ";";
  });
}
function textToHtml(str) {
  let html = escapeHtml(str).replace(/\n/g, "<br />");
  return "<div>" + html + "</div>";
}
function htmlToText(str) {
  str = str.replace(/\r?\n/g, "").replace(/<\!\-\-.*?\-\->/gi, " ").replace(/<br\b[^>]*>/gi, "\n").replace(/<\/?(p|div|table|tr|td|th)\b[^>]*>/gi, "\n\n").replace(/<script\b[^>]*>.*?<\/script\b[^>]*>/gi, " ").replace(/^.*<body\b[^>]*>/i, "").replace(/^.*<\/head\b[^>]*>/i, "").replace(/^.*<\!doctype\b[^>]*>/i, "").replace(/<\/body\b[^>]*>.*$/i, "").replace(/<\/html\b[^>]*>.*$/i, "").replace(/<a\b[^>]*href\s*=\s*["']?([^\s"']+)[^>]*>/gi, " ($1) ").replace(/<\/?(span|em|i|strong|b|u|a)\b[^>]*>/gi, "").replace(/<li\b[^>]*>[\n\u0001\s]*/gi, "* ").replace(/<hr\b[^>]*>/g, "\n-------------\n").replace(/<[^>]*>/g, " ").replace(/\u0001/g, "\n").replace(/[ \t]+/g, " ").replace(/^\s+$/gm, "").replace(/\n\n+/g, "\n\n").replace(/^\n+/, "\n").replace(/\n+$/, "\n");
  str = decodeHTMLEntities(str);
  return str;
}
function formatTextAddress(address) {
  return [].concat(address.name || []).concat(address.name ? `<${address.address}>` : address.address).join(" ");
}
function formatTextAddresses(addresses) {
  let parts = [];
  let processAddress = (address, partCounter) => {
    if (partCounter) {
      parts.push(", ");
    }
    if (address.group) {
      let groupStart = `${address.name}:`;
      let groupEnd = `;`;
      parts.push(groupStart);
      address.group.forEach(processAddress);
      parts.push(groupEnd);
    } else {
      parts.push(formatTextAddress(address));
    }
  };
  addresses.forEach(processAddress);
  return parts.join("");
}
function formatHtmlAddress(address) {
  return `<a href="mailto:${escapeHtml(address.address)}" class="postal-email-address">${escapeHtml(address.name || `<${address.address}>`)}</a>`;
}
function formatHtmlAddresses(addresses) {
  let parts = [];
  let processAddress = (address, partCounter) => {
    if (partCounter) {
      parts.push('<span class="postal-email-address-separator">, </span>');
    }
    if (address.group) {
      let groupStart = `<span class="postal-email-address-group">${escapeHtml(address.name)}:</span>`;
      let groupEnd = `<span class="postal-email-address-group">;</span>`;
      parts.push(groupStart);
      address.group.forEach(processAddress);
      parts.push(groupEnd);
    } else {
      parts.push(formatHtmlAddress(address));
    }
  };
  addresses.forEach(processAddress);
  return parts.join(" ");
}
function foldLines(str, lineLength, afterSpace) {
  str = (str || "").toString();
  lineLength = lineLength || 76;
  let pos = 0, len = str.length, result = "", line, match;
  while (pos < len) {
    line = str.substr(pos, lineLength);
    if (line.length < lineLength) {
      result += line;
      break;
    }
    if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
      line = match[0];
      result += line;
      pos += line.length;
      continue;
    } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
      line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
    } else if (match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/)) {
      line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
    }
    result += line;
    pos += line.length;
    if (pos < len) {
      result += "\r\n";
    }
  }
  return result;
}
function formatTextHeader(message) {
  let rows = [];
  if (message.from) {
    rows.push({ key: "From", val: formatTextAddress(message.from) });
  }
  if (message.subject) {
    rows.push({ key: "Subject", val: message.subject });
  }
  if (message.date) {
    let dateOptions = {
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      hour12: false
    };
    let dateStr = typeof Intl === "undefined" ? message.date : new Intl.DateTimeFormat("default", dateOptions).format(new Date(message.date));
    rows.push({ key: "Date", val: dateStr });
  }
  if (message.to && message.to.length) {
    rows.push({ key: "To", val: formatTextAddresses(message.to) });
  }
  if (message.cc && message.cc.length) {
    rows.push({ key: "Cc", val: formatTextAddresses(message.cc) });
  }
  if (message.bcc && message.bcc.length) {
    rows.push({ key: "Bcc", val: formatTextAddresses(message.bcc) });
  }
  let maxKeyLength = rows.map((r) => r.key.length).reduce((acc, cur) => {
    return cur > acc ? cur : acc;
  }, 0);
  rows = rows.flatMap((row) => {
    let sepLen = maxKeyLength - row.key.length;
    let prefix = `${row.key}: ${" ".repeat(sepLen)}`;
    let emptyPrefix = `${" ".repeat(row.key.length + 1)} ${" ".repeat(sepLen)}`;
    let foldedLines = foldLines(row.val, 80, true).split(/\r?\n/).map((line) => line.trim());
    return foldedLines.map((line, i) => `${i ? emptyPrefix : prefix}${line}`);
  });
  let maxLineLength = rows.map((r) => r.length).reduce((acc, cur) => {
    return cur > acc ? cur : acc;
  }, 0);
  let lineMarker = "-".repeat(maxLineLength);
  let template = `
${lineMarker}
${rows.join("\n")}
${lineMarker}
`;
  return template;
}
function formatHtmlHeader(message) {
  let rows = [];
  if (message.from) {
    rows.push(`<div class="postal-email-header-key">From</div><div class="postal-email-header-value">${formatHtmlAddress(message.from)}</div>`);
  }
  if (message.subject) {
    rows.push(
      `<div class="postal-email-header-key">Subject</div><div class="postal-email-header-value postal-email-header-subject">${escapeHtml(
        message.subject
      )}</div>`
    );
  }
  if (message.date) {
    let dateOptions = {
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      hour12: false
    };
    let dateStr = typeof Intl === "undefined" ? message.date : new Intl.DateTimeFormat("default", dateOptions).format(new Date(message.date));
    rows.push(
      `<div class="postal-email-header-key">Date</div><div class="postal-email-header-value postal-email-header-date" data-date="${escapeHtml(
        message.date
      )}">${escapeHtml(dateStr)}</div>`
    );
  }
  if (message.to && message.to.length) {
    rows.push(`<div class="postal-email-header-key">To</div><div class="postal-email-header-value">${formatHtmlAddresses(message.to)}</div>`);
  }
  if (message.cc && message.cc.length) {
    rows.push(`<div class="postal-email-header-key">Cc</div><div class="postal-email-header-value">${formatHtmlAddresses(message.cc)}</div>`);
  }
  if (message.bcc && message.bcc.length) {
    rows.push(`<div class="postal-email-header-key">Bcc</div><div class="postal-email-header-value">${formatHtmlAddresses(message.bcc)}</div>`);
  }
  let template = `<div class="postal-email-header">${rows.length ? '<div class="postal-email-header-row">' : ""}${rows.join(
    '</div>\n<div class="postal-email-header-row">'
  )}${rows.length ? "</div>" : ""}</div>`;
  return template;
}

// node_modules/postal-mime/src/address-parser.js
function _handleAddress(tokens) {
  let token;
  let isGroup = false;
  let state = "text";
  let address;
  let addresses = [];
  let data = {
    address: [],
    comment: [],
    group: [],
    text: []
  };
  let i;
  let len;
  for (i = 0, len = tokens.length; i < len; i++) {
    token = tokens[i];
    if (token.type === "operator") {
      switch (token.value) {
        case "<":
          state = "address";
          break;
        case "(":
          state = "comment";
          break;
        case ":":
          state = "group";
          isGroup = true;
          break;
        default:
          state = "text";
      }
    } else if (token.value) {
      if (state === "address") {
        token.value = token.value.replace(/^[^<]*<\s*/, "");
      }
      data[state].push(token.value);
    }
  }
  if (!data.text.length && data.comment.length) {
    data.text = data.comment;
    data.comment = [];
  }
  if (isGroup) {
    data.text = data.text.join(" ");
    addresses.push({
      name: decodeWords(data.text || address && address.name),
      group: data.group.length ? addressParser(data.group.join(",")) : []
    });
  } else {
    if (!data.address.length && data.text.length) {
      for (i = data.text.length - 1; i >= 0; i--) {
        if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
          data.address = data.text.splice(i, 1);
          break;
        }
      }
      let _regexHandler = function(address2) {
        if (!data.address.length) {
          data.address = [address2.trim()];
          return " ";
        } else {
          return address2;
        }
      };
      if (!data.address.length) {
        for (i = data.text.length - 1; i >= 0; i--) {
          data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
          if (data.address.length) {
            break;
          }
        }
      }
    }
    if (!data.text.length && data.comment.length) {
      data.text = data.comment;
      data.comment = [];
    }
    if (data.address.length > 1) {
      data.text = data.text.concat(data.address.splice(1));
    }
    data.text = data.text.join(" ");
    data.address = data.address.join(" ");
    if (!data.address && /^=\?[^=]+?=$/.test(data.text.trim())) {
      const parsedSubAddresses = addressParser(decodeWords(data.text));
      if (parsedSubAddresses && parsedSubAddresses.length) {
        return parsedSubAddresses;
      }
    }
    if (!data.address && isGroup) {
      return [];
    } else {
      address = {
        address: data.address || data.text || "",
        name: decodeWords(data.text || data.address || "")
      };
      if (address.address === address.name) {
        if ((address.address || "").match(/@/)) {
          address.name = "";
        } else {
          address.address = "";
        }
      }
      addresses.push(address);
    }
  }
  return addresses;
}
var Tokenizer = class {
  constructor(str) {
    this.str = (str || "").toString();
    this.operatorCurrent = "";
    this.operatorExpecting = "";
    this.node = null;
    this.escaped = false;
    this.list = [];
    this.operators = {
      '"': '"',
      "(": ")",
      "<": ">",
      ",": "",
      ":": ";",
      // Semicolons are not a legal delimiter per the RFC2822 grammar other
      // than for terminating a group, but they are also not valid for any
      // other use in this context.  Given that some mail clients have
      // historically allowed the semicolon as a delimiter equivalent to the
      // comma in their UI, it makes sense to treat them the same as a comma
      // when used outside of a group.
      ";": ""
    };
  }
  /**
   * Tokenizes the original input string
   *
   * @return {Array} An array of operator|text tokens
   */
  tokenize() {
    let chr, list = [];
    for (let i = 0, len = this.str.length; i < len; i++) {
      chr = this.str.charAt(i);
      this.checkChar(chr);
    }
    this.list.forEach((node) => {
      node.value = (node.value || "").toString().trim();
      if (node.value) {
        list.push(node);
      }
    });
    return list;
  }
  /**
   * Checks if a character is an operator or text and acts accordingly
   *
   * @param {String} chr Character from the address field
   */
  checkChar(chr) {
    if (this.escaped) {
    } else if (chr === this.operatorExpecting) {
      this.node = {
        type: "operator",
        value: chr
      };
      this.list.push(this.node);
      this.node = null;
      this.operatorExpecting = "";
      this.escaped = false;
      return;
    } else if (!this.operatorExpecting && chr in this.operators) {
      this.node = {
        type: "operator",
        value: chr
      };
      this.list.push(this.node);
      this.node = null;
      this.operatorExpecting = this.operators[chr];
      this.escaped = false;
      return;
    } else if (['"', "'"].includes(this.operatorExpecting) && chr === "\\") {
      this.escaped = true;
      return;
    }
    if (!this.node) {
      this.node = {
        type: "text",
        value: ""
      };
      this.list.push(this.node);
    }
    if (chr === "\n") {
      chr = " ";
    }
    if (chr.charCodeAt(0) >= 33 || [" ", "	"].includes(chr)) {
      this.node.value += chr;
    }
    this.escaped = false;
  }
};
function addressParser(str, options) {
  options = options || {};
  let tokenizer = new Tokenizer(str);
  let tokens = tokenizer.tokenize();
  let addresses = [];
  let address = [];
  let parsedAddresses = [];
  tokens.forEach((token) => {
    if (token.type === "operator" && (token.value === "," || token.value === ";")) {
      if (address.length) {
        addresses.push(address);
      }
      address = [];
    } else {
      address.push(token);
    }
  });
  if (address.length) {
    addresses.push(address);
  }
  addresses.forEach((address2) => {
    address2 = _handleAddress(address2);
    if (address2.length) {
      parsedAddresses = parsedAddresses.concat(address2);
    }
  });
  if (options.flatten) {
    let addresses2 = [];
    let walkAddressList = (list) => {
      list.forEach((address2) => {
        if (address2.group) {
          return walkAddressList(address2.group);
        } else {
          addresses2.push(address2);
        }
      });
    };
    walkAddressList(parsedAddresses);
    return addresses2;
  }
  return parsedAddresses;
}
var address_parser_default = addressParser;

// node_modules/postal-mime/src/base64-encoder.js
function base64ArrayBuffer(arrayBuffer) {
  var base64 = "";
  var encodings = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var bytes = new Uint8Array(arrayBuffer);
  var byteLength = bytes.byteLength;
  var byteRemainder = byteLength % 3;
  var mainLength = byteLength - byteRemainder;
  var a, b, c, d;
  var chunk;
  for (var i = 0; i < mainLength; i = i + 3) {
    chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
    a = (chunk & 16515072) >> 18;
    b = (chunk & 258048) >> 12;
    c = (chunk & 4032) >> 6;
    d = chunk & 63;
    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
  }
  if (byteRemainder == 1) {
    chunk = bytes[mainLength];
    a = (chunk & 252) >> 2;
    b = (chunk & 3) << 4;
    base64 += encodings[a] + encodings[b] + "==";
  } else if (byteRemainder == 2) {
    chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];
    a = (chunk & 64512) >> 10;
    b = (chunk & 1008) >> 4;
    c = (chunk & 15) << 2;
    base64 += encodings[a] + encodings[b] + encodings[c] + "=";
  }
  return base64;
}

// node_modules/postal-mime/src/postal-mime.js
var PostalMime = class _PostalMime {
  static parse(buf, options) {
    const parser = new _PostalMime(options);
    return parser.parse(buf);
  }
  constructor(options) {
    this.options = options || {};
    this.root = this.currentNode = new MimeNode({
      postalMime: this
    });
    this.boundaries = [];
    this.textContent = {};
    this.attachments = [];
    this.attachmentEncoding = (this.options.attachmentEncoding || "").toString().replace(/[-_\s]/g, "").trim().toLowerCase() || "arraybuffer";
    this.started = false;
  }
  async finalize() {
    await this.root.finalize();
  }
  async processLine(line, isFinal) {
    let boundaries = this.boundaries;
    if (boundaries.length && line.length > 2 && line[0] === 45 && line[1] === 45) {
      for (let i = boundaries.length - 1; i >= 0; i--) {
        let boundary = boundaries[i];
        if (line.length !== boundary.value.length + 2 && line.length !== boundary.value.length + 4) {
          continue;
        }
        let isTerminator = line.length === boundary.value.length + 4;
        if (isTerminator && (line[line.length - 2] !== 45 || line[line.length - 1] !== 45)) {
          continue;
        }
        let boudaryMatches = true;
        for (let i2 = 0; i2 < boundary.value.length; i2++) {
          if (line[i2 + 2] !== boundary.value[i2]) {
            boudaryMatches = false;
            break;
          }
        }
        if (!boudaryMatches) {
          continue;
        }
        if (isTerminator) {
          await boundary.node.finalize();
          this.currentNode = boundary.node.parentNode || this.root;
        } else {
          await boundary.node.finalizeChildNodes();
          this.currentNode = new MimeNode({
            postalMime: this,
            parentNode: boundary.node
          });
        }
        if (isFinal) {
          return this.finalize();
        }
        return;
      }
    }
    this.currentNode.feed(line);
    if (isFinal) {
      return this.finalize();
    }
  }
  readLine() {
    let startPos = this.readPos;
    let endPos = this.readPos;
    let res = () => {
      return {
        bytes: new Uint8Array(this.buf, startPos, endPos - startPos),
        done: this.readPos >= this.av.length
      };
    };
    while (this.readPos < this.av.length) {
      const c = this.av[this.readPos++];
      if (c !== 13 && c !== 10) {
        endPos = this.readPos;
      }
      if (c === 10) {
        return res();
      }
    }
    return res();
  }
  async processNodeTree() {
    let textContent = {};
    let textTypes = /* @__PURE__ */ new Set();
    let textMap = this.textMap = /* @__PURE__ */ new Map();
    let forceRfc822Attachments = this.forceRfc822Attachments();
    let walk = async (node, alternative, related) => {
      alternative = alternative || false;
      related = related || false;
      if (!node.contentType.multipart) {
        if (this.isInlineMessageRfc822(node) && !forceRfc822Attachments) {
          const subParser = new _PostalMime();
          node.subMessage = await subParser.parse(node.content);
          if (!textMap.has(node)) {
            textMap.set(node, {});
          }
          let textEntry = textMap.get(node);
          if (node.subMessage.text || !node.subMessage.html) {
            textEntry.plain = textEntry.plain || [];
            textEntry.plain.push({ type: "subMessage", value: node.subMessage });
            textTypes.add("plain");
          }
          if (node.subMessage.html) {
            textEntry.html = textEntry.html || [];
            textEntry.html.push({ type: "subMessage", value: node.subMessage });
            textTypes.add("html");
          }
          if (subParser.textMap) {
            subParser.textMap.forEach((subTextEntry, subTextNode) => {
              textMap.set(subTextNode, subTextEntry);
            });
          }
          for (let attachment of node.subMessage.attachments || []) {
            this.attachments.push(attachment);
          }
        } else if (this.isInlineTextNode(node)) {
          let textType = node.contentType.parsed.value.substr(node.contentType.parsed.value.indexOf("/") + 1);
          let selectorNode = alternative || node;
          if (!textMap.has(selectorNode)) {
            textMap.set(selectorNode, {});
          }
          let textEntry = textMap.get(selectorNode);
          textEntry[textType] = textEntry[textType] || [];
          textEntry[textType].push({ type: "text", value: node.getTextContent() });
          textTypes.add(textType);
        } else if (node.content) {
          const filename = node.contentDisposition.parsed.params.filename || node.contentType.parsed.params.name || null;
          const attachment = {
            filename: filename ? decodeWords(filename) : null,
            mimeType: node.contentType.parsed.value,
            disposition: node.contentDisposition.parsed.value || null
          };
          if (related && node.contentId) {
            attachment.related = true;
          }
          if (node.contentDescription) {
            attachment.description = node.contentDescription;
          }
          if (node.contentId) {
            attachment.contentId = node.contentId;
          }
          switch (node.contentType.parsed.value) {
            // Special handling for calendar events
            case "text/calendar":
            case "application/ics": {
              if (node.contentType.parsed.params.method) {
                attachment.method = node.contentType.parsed.params.method.toString().toUpperCase().trim();
              }
              const decodedText = node.getTextContent().replace(/\r?\n/g, "\n").replace(/\n*$/, "\n");
              attachment.content = textEncoder.encode(decodedText);
              break;
            }
            // Regular attachments
            default:
              attachment.content = node.content;
          }
          this.attachments.push(attachment);
        }
      } else if (node.contentType.multipart === "alternative") {
        alternative = node;
      } else if (node.contentType.multipart === "related") {
        related = node;
      }
      for (let childNode of node.childNodes) {
        await walk(childNode, alternative, related);
      }
    };
    await walk(this.root, false, []);
    textMap.forEach((mapEntry) => {
      textTypes.forEach((textType) => {
        if (!textContent[textType]) {
          textContent[textType] = [];
        }
        if (mapEntry[textType]) {
          mapEntry[textType].forEach((textEntry) => {
            switch (textEntry.type) {
              case "text":
                textContent[textType].push(textEntry.value);
                break;
              case "subMessage":
                {
                  switch (textType) {
                    case "html":
                      textContent[textType].push(formatHtmlHeader(textEntry.value));
                      break;
                    case "plain":
                      textContent[textType].push(formatTextHeader(textEntry.value));
                      break;
                  }
                }
                break;
            }
          });
        } else {
          let alternativeType;
          switch (textType) {
            case "html":
              alternativeType = "plain";
              break;
            case "plain":
              alternativeType = "html";
              break;
          }
          (mapEntry[alternativeType] || []).forEach((textEntry) => {
            switch (textEntry.type) {
              case "text":
                switch (textType) {
                  case "html":
                    textContent[textType].push(textToHtml(textEntry.value));
                    break;
                  case "plain":
                    textContent[textType].push(htmlToText(textEntry.value));
                    break;
                }
                break;
              case "subMessage":
                {
                  switch (textType) {
                    case "html":
                      textContent[textType].push(formatHtmlHeader(textEntry.value));
                      break;
                    case "plain":
                      textContent[textType].push(formatTextHeader(textEntry.value));
                      break;
                  }
                }
                break;
            }
          });
        }
      });
    });
    Object.keys(textContent).forEach((textType) => {
      textContent[textType] = textContent[textType].join("\n");
    });
    this.textContent = textContent;
  }
  isInlineTextNode(node) {
    if (node.contentDisposition.parsed.value === "attachment") {
      return false;
    }
    switch (node.contentType.parsed.value) {
      case "text/html":
      case "text/plain":
        return true;
      case "text/calendar":
      case "text/csv":
      default:
        return false;
    }
  }
  isInlineMessageRfc822(node) {
    if (node.contentType.parsed.value !== "message/rfc822") {
      return false;
    }
    let disposition = node.contentDisposition.parsed.value || (this.options.rfc822Attachments ? "attachment" : "inline");
    return disposition === "inline";
  }
  // Check if this is a specially crafted report email where message/rfc822 content should not be inlined
  forceRfc822Attachments() {
    if (this.options.forceRfc822Attachments) {
      return true;
    }
    let forceRfc822Attachments = false;
    let walk = (node) => {
      if (!node.contentType.multipart) {
        if (["message/delivery-status", "message/feedback-report"].includes(node.contentType.parsed.value)) {
          forceRfc822Attachments = true;
        }
      }
      for (let childNode of node.childNodes) {
        walk(childNode);
      }
    };
    walk(this.root);
    return forceRfc822Attachments;
  }
  async resolveStream(stream) {
    let chunkLen = 0;
    let chunks = [];
    const reader = stream.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      chunks.push(value);
      chunkLen += value.length;
    }
    const result = new Uint8Array(chunkLen);
    let chunkPointer = 0;
    for (let chunk of chunks) {
      result.set(chunk, chunkPointer);
      chunkPointer += chunk.length;
    }
    return result;
  }
  async parse(buf) {
    if (this.started) {
      throw new Error("Can not reuse parser, create a new PostalMime object");
    }
    this.started = true;
    if (buf && typeof buf.getReader === "function") {
      buf = await this.resolveStream(buf);
    }
    buf = buf || new ArrayBuffer(0);
    if (typeof buf === "string") {
      buf = textEncoder.encode(buf);
    }
    if (buf instanceof Blob || Object.prototype.toString.call(buf) === "[object Blob]") {
      buf = await blobToArrayBuffer(buf);
    }
    if (buf.buffer instanceof ArrayBuffer) {
      buf = new Uint8Array(buf).buffer;
    }
    this.buf = buf;
    this.av = new Uint8Array(buf);
    this.readPos = 0;
    while (this.readPos < this.av.length) {
      const line = this.readLine();
      await this.processLine(line.bytes, line.done);
    }
    await this.processNodeTree();
    const message = {
      headers: this.root.headers.map((entry) => ({ key: entry.key, value: entry.value })).reverse()
    };
    for (const key of ["from", "sender"]) {
      const addressHeader = this.root.headers.find((line) => line.key === key);
      if (addressHeader && addressHeader.value) {
        const addresses = address_parser_default(addressHeader.value);
        if (addresses && addresses.length) {
          message[key] = addresses[0];
        }
      }
    }
    for (const key of ["delivered-to", "return-path"]) {
      const addressHeader = this.root.headers.find((line) => line.key === key);
      if (addressHeader && addressHeader.value) {
        const addresses = address_parser_default(addressHeader.value);
        if (addresses && addresses.length && addresses[0].address) {
          const camelKey = key.replace(/\-(.)/g, (o, c) => c.toUpperCase());
          message[camelKey] = addresses[0].address;
        }
      }
    }
    for (const key of ["to", "cc", "bcc", "reply-to"]) {
      const addressHeaders = this.root.headers.filter((line) => line.key === key);
      let addresses = [];
      addressHeaders.filter((entry) => entry && entry.value).map((entry) => address_parser_default(entry.value)).forEach((parsed) => addresses = addresses.concat(parsed || []));
      if (addresses && addresses.length) {
        const camelKey = key.replace(/\-(.)/g, (o, c) => c.toUpperCase());
        message[camelKey] = addresses;
      }
    }
    for (const key of ["subject", "message-id", "in-reply-to", "references"]) {
      const header = this.root.headers.find((line) => line.key === key);
      if (header && header.value) {
        const camelKey = key.replace(/\-(.)/g, (o, c) => c.toUpperCase());
        message[camelKey] = decodeWords(header.value);
      }
    }
    let dateHeader = this.root.headers.find((line) => line.key === "date");
    if (dateHeader) {
      let date = new Date(dateHeader.value);
      if (!date || date.toString() === "Invalid Date") {
        date = dateHeader.value;
      } else {
        date = date.toISOString();
      }
      message.date = date;
    }
    if (this.textContent?.html) {
      message.html = this.textContent.html;
    }
    if (this.textContent?.plain) {
      message.text = this.textContent.plain;
    }
    message.attachments = this.attachments;
    switch (this.attachmentEncoding) {
      case "arraybuffer":
        break;
      case "base64":
        for (let attachment of message.attachments || []) {
          if (attachment?.content) {
            attachment.content = base64ArrayBuffer(attachment.content);
            attachment.encoding = "base64";
          }
        }
        break;
      case "utf8":
        let attachmentDecoder = new TextDecoder("utf8");
        for (let attachment of message.attachments || []) {
          if (attachment?.content) {
            attachment.content = attachmentDecoder.decode(attachment.content);
            attachment.encoding = "utf8";
          }
        }
        break;
      default:
        throw new Error("Unknwon attachment encoding");
    }
    return message;
  }
};
export {
  address_parser_default as addressParser,
  decodeWords,
  PostalMime as default
};
//# sourceMappingURL=postal-mime.js.map
